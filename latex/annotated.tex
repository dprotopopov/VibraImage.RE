\section{Class List}
Here are the classes, structs, unions and interfaces with brief descriptions\+:\begin{DoxyCompactList}
\item\contentsline{section}{\hyperlink{class_a_u_r_a___s_t_a_t}{A\+U\+R\+A\+\_\+\+S\+T\+A\+T} \\*Структура для хранения статистики по вычисленному дельта-\/изображению }{\pageref{class_a_u_r_a___s_t_a_t}}{}
\item\contentsline{section}{\hyperlink{class_a_u_r_a___s_t_a_t___l_i_n_e}{A\+U\+R\+A\+\_\+\+S\+T\+A\+T\+\_\+\+L\+I\+N\+E} }{\pageref{class_a_u_r_a___s_t_a_t___l_i_n_e}}{}
\item\contentsline{section}{\hyperlink{class_c_m_t_single_lock}{C\+M\+T\+Single\+Lock} \\*предположительно данный класс является классом для управления доступом к ресурсам в многопоточных приложениях Represents the access-\/control mechanism used in controlling access to a resource in a multithreaded program. \href{http://msdn.microsoft.com/en-us/library/bwk62eb7.aspx}{\tt http\+://msdn.\+microsoft.\+com/en-\/us/library/bwk62eb7.\+aspx} }{\pageref{class_c_m_t_single_lock}}{}
\item\contentsline{section}{\hyperlink{class_c_point_s_s_e}{C\+Point\+S\+S\+E} \\*Структура для работы с пикселем в видеопамяти по технологии S\+S\+E. Каждый пискель в видеопамяти является блоком из 4-\/х регистров для обработки 4-\/х каналов сигнала R\+G\+B\+A. Которые могут записыватся и считыватся в-\/из видеопамять из-\/в ОЗУ как целые числа и как числа с плавающей точкой. Благодаря этой возможности видеопамяти применяют аппаратное ускорение вычислений при преобразовании типов данных из float в int и обратно, либо при выполнении сложения-\/умножения. То есть достаточно записать в регистры видеопамятм 4 числа с плавающей точкой, а потом считать эти же 4 числа как целые. Реальный способ представления данных в видеопамяти определяет производитель оборудования, и как правило это хранение мантисы из диапазона \mbox{[}0.\+0;1.\+0\mbox{]}. При этом одновременно при чтении-\/записи может производится умножение-\/деление на некоторую величину хранящуюся в системном регистре видеокарты. Технология S\+S\+E уже является устаревшей. Современные видеокарты N\+V\+I\+D\+I\+A поддерживают технологию C\+U\+D\+A, позволяющей создавать полноценные программы для параллельных вычислений на видеокартах. Однако стоимость вычислений и возможность параллельных вычислений не всегда находятся в прямой зависимости друкг от друга. Дорогой процессор будет всегда делать вычисления быстрее дешовой видеокарты, сколько бы там шредеров не было -\/ чудес не бывает. }{\pageref{class_c_point_s_s_e}}{}
\item\contentsline{section}{\hyperlink{class_c_v_i_engine_base}{C\+V\+I\+Engine\+Base} \\*Базовый класс для описания алгоритмов программы. Поддерживает выполнение расчётов в многопоточной среде. В программе создаётся только один инстанс данного класса. }{\pageref{class_c_v_i_engine_base}}{}
\item\contentsline{section}{\hyperlink{class_c_v_i_engine_config}{C\+V\+I\+Engine\+Config} \\*Класс предназначен для управления списком настроечных параметров алгоритмов программы. В программе создаётся только один инстанс данного класса (реализован как член m\+\_\+cfg класса \hyperlink{class_c_v_i_engine_base}{C\+V\+I\+Engine\+Base}). }{\pageref{class_c_v_i_engine_config}}{}
\item\contentsline{section}{\hyperlink{class_c_v_i_engine_event}{C\+V\+I\+Engine\+Event} \\*Предположительно данный класс является программно управляемым событийным триггером }{\pageref{class_c_v_i_engine_event}}{}
\item\contentsline{section}{\hyperlink{class_c_v_i_engine_simple}{C\+V\+I\+Engine\+Simple} \\*Класс реализации алгоритмов подавлени¤ шумов (фильтров) с использованием возможностей технологии S\+S\+E. Реализаци¤ не известна, но не имеет никакого значени¤ -\/ можно выбрить любой фильтр подавлени¤ шумов. }{\pageref{class_c_v_i_engine_simple}}{}
\item\contentsline{section}{\hyperlink{class_c_v_i_engine_thread}{C\+V\+I\+Engine\+Thread} \\*Класс для реализации расчётов в многопоточной среде. Является классом для управления одним потоком расчётов. Ускорение рассчётов достигается за счёт создания нескольких инстансов данного класса (потоков вычисления), одновременно производящмх общёт изображения. Разделение заданий происходит с помощью разделения между потоками диапазонов строк обрабатываемого изображения. Диапазон обрабатываемых строк инстансом данного класа задаётся членами класса m\+\_\+y\+S,m\+\_\+y\+E. Аналогичное разделение заданий между процессами реализованно в проекте \href{https://github.com/dprotopopov/MedianFilter}{\tt https\+://github.\+com/dprotopopov/\+Median\+Filter}. Сужествуют и другие способы разделения заданий -\/ но от перемены слагаемых сумма не меняется. }{\pageref{class_c_v_i_engine_thread}}{}
\item\contentsline{section}{\hyperlink{class_c_v_i_timer}{C\+V\+I\+Timer} \\*Класс для работы с системными часами }{\pageref{class_c_v_i_timer}}{}
\item\contentsline{section}{\hyperlink{class_f_r_a_m_e___i_m_g}{F\+R\+A\+M\+E\+\_\+\+I\+M\+G} \\*Структура для работы с фрагментами монохромных изображений. Монохромные изображения хранятся в виде последовательности чисел с плавающей точкой. Каждое число соответствует уровню яркости одного пикселя монохромного изображения. Предположительно несколько кадров изображений хранятся в виде одного последовательного массива }{\pageref{class_f_r_a_m_e___i_m_g}}{}
\item\contentsline{section}{\hyperlink{classil_f_r_a_m_e___i_m_g}{il\+F\+R\+A\+M\+E\+\_\+\+I\+M\+G} \\*Элемент массива для работы с фрагментами монохромных изображений }{\pageref{classil_f_r_a_m_e___i_m_g}}{}
\item\contentsline{section}{\hyperlink{classl_f_r_a_m_e___i_m_g}{l\+F\+R\+A\+M\+E\+\_\+\+I\+M\+G} \\*Массив для работы с фрагментами монохромных изображений }{\pageref{classl_f_r_a_m_e___i_m_g}}{}
\item\contentsline{section}{\hyperlink{classmmx__array}{mmx\+\_\+array$<$ T $>$} \\*Структура для хранения одномерных массивов заданного типа данных Вероятно оптимизирован для работы с видеопамятью }{\pageref{classmmx__array}}{}
\item\contentsline{section}{\hyperlink{classmmx__array2}{mmx\+\_\+array2$<$ T $>$} \\*Структура для хранения двухмерных массивов заданного типа данных Вероятно оптимизирован для работы с видеопамятью }{\pageref{classmmx__array2}}{}
\item\contentsline{section}{\hyperlink{class_s_u_m___i_m_g}{S\+U\+M\+\_\+\+I\+M\+G} \\*Структура для работы с монохромными изображениями. Монохромные изображения хранятся в виде последовательности чисел с плавающей точкой. Каждое число соответствует уровню яркости одного пикселя монохромного изображения. Предположительно несколько кадров изображений хранятся в виде одного последовательного массива }{\pageref{class_s_u_m___i_m_g}}{}
\item\contentsline{section}{\hyperlink{class_s_u_m_m___s_t_a_t}{S\+U\+M\+M\+\_\+\+S\+T\+A\+T} \\*Структура для хранения статистики по вычисленному дельта-\/изображению }{\pageref{class_s_u_m_m___s_t_a_t}}{}
\item\contentsline{section}{\hyperlink{struct_c_v_i_engine_thread_1_1tag_s_u_m_m___p_t_r}{C\+V\+I\+Engine\+Thread\+::tag\+S\+U\+M\+M\+\_\+\+P\+T\+R} }{\pageref{struct_c_v_i_engine_thread_1_1tag_s_u_m_m___p_t_r}}{}
\item\contentsline{section}{\hyperlink{struct_c_v_i_engine_thread_1_1tag_t_m_p___a_u_r_a___s_t_a_t}{C\+V\+I\+Engine\+Thread\+::tag\+T\+M\+P\+\_\+\+A\+U\+R\+A\+\_\+\+S\+T\+A\+T} }{\pageref{struct_c_v_i_engine_thread_1_1tag_t_m_p___a_u_r_a___s_t_a_t}}{}
\item\contentsline{section}{\hyperlink{struct_c_v_i_engine_thread_1_1tag_t_m_p___s_t_a_t}{C\+V\+I\+Engine\+Thread\+::tag\+T\+M\+P\+\_\+\+S\+T\+A\+T} \\*Структура для хранения статистики по вычисленному фрагменту дельта-\/изображения для одного процесса }{\pageref{struct_c_v_i_engine_thread_1_1tag_t_m_p___s_t_a_t}}{}
\end{DoxyCompactList}
