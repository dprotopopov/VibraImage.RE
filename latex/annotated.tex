\section{Class List}
Here are the classes, structs, unions and interfaces with brief descriptions\+:\begin{DoxyCompactList}
\item\contentsline{section}{\hyperlink{class_a_u_r_a___s_t_a_t}{A\+U\+R\+A\+\_\+\+S\+T\+A\+T} \\*Структура для хранения статистики по вычисленному дельта-\/изображению }{\pageref{class_a_u_r_a___s_t_a_t}}{}
\item\contentsline{section}{\hyperlink{class_a_u_r_a___s_t_a_t___l_i_n_e}{A\+U\+R\+A\+\_\+\+S\+T\+A\+T\+\_\+\+L\+I\+N\+E} }{\pageref{class_a_u_r_a___s_t_a_t___l_i_n_e}}{}
\item\contentsline{section}{\hyperlink{class_c_m_t_single_lock}{C\+M\+T\+Single\+Lock} \\*Данный класс является классом для управления доступом к ресурсам в многопоточных приложениях Represents the access-\/control mechanism used in controlling access to a resource in a multithreaded program. \href{http://msdn.microsoft.com/en-us/library/bwk62eb7.aspx}{\tt http\+://msdn.\+microsoft.\+com/en-\/us/library/bwk62eb7.\+aspx} }{\pageref{class_c_m_t_single_lock}}{}
\item\contentsline{section}{\hyperlink{class_c_point_s_s_e}{C\+Point\+S\+S\+E} \\*Структура для работы с пикселем в видеопамяти по технологии S\+S\+E. Каждый пискель в видеопамяти является блоком из 4-\/х регистров для обработки 4-\/х каналов сигнала R\+G\+B\+A. Которые могут записыватся и считыватся в-\/из видеопамять из-\/в ОЗУ как целые числа и как числа с плавающей точкой. Благодаря этой возможности видеопамяти применяют аппаратное ускорение вычислений при преобразовании типов данных из float в int и обратно, либо при выполнении сложения-\/умножения. То есть достаточно записать в регистры видеопамятм 4 числа с плавающей точкой, а потом считать эти же 4 числа как целые. Реальный способ представления данных в видеопамяти определяет производитель оборудования, и как правило это хранение мантисы из диапазона \mbox{[}0.\+0;1.\+0\mbox{]}. При этом одновременно при чтении-\/записи может производится умножение-\/деление на некоторую величину хранящуюся в системном регистре видеокарты. Технология S\+S\+E уже является устаревшей. Современные видеокарты N\+V\+I\+D\+I\+A поддерживают технологию C\+U\+D\+A, позволяющей создавать полноценные программы для параллельных вычислений на видеокартах. Однако стоимость вычислений и возможность параллельных вычислений не всегда находятся в прямой зависимости друкг от друга. Дорогой процессор будет всегда делать вычисления быстрее дешовой видеокарты, сколько бы там шредеров не было -\/ чудес не бывает. }{\pageref{class_c_point_s_s_e}}{}
\item\contentsline{section}{\hyperlink{class_c_v_i_engine_audio2}{C\+V\+I\+Engine\+Audio2} \\*Видимо реализация A\+P\+I для управления камерой и микрофоном. Вполне возможно что автор сперва сделал полиграф для голоса, а для видео потом расписал. А название осталось. Вероятнее всего просто запускается параллельная нить в Windows? которая отвечает за захват изображения и звука через стандартные A\+P\+I мультимедиа Windows, и выдаёт результат в программу по запросам от программы. }{\pageref{class_c_v_i_engine_audio2}}{}
\item\contentsline{section}{\hyperlink{class_c_v_i_engine_base}{C\+V\+I\+Engine\+Base} \\*Базовый класс для описания алгоритмов программы. Поддерживает выполнение расчётов в многопоточной среде. В программе создаётся только один инстанс данного класса. Для ускорения расчётов он создаёт несколько дочерних инстансов класса \hyperlink{class_c_v_i_engine_thread}{C\+V\+I\+Engine\+Thread}, выполняющих обсчёт отдельных фрагментов полного изображения в параллельных нитях на компьютере. Количество создаваемых инстансов класса \hyperlink{class_c_v_i_engine_thread}{C\+V\+I\+Engine\+Thread} равно количеству процессоров на компьютере, но не более 8-\/ми. В свою очередь выполнение методов данного класса осуществляется так же в одной из созданных нитей параллельных вычислений, то есть инстанс класса создаётся и управляется внешними механизмами программы как обычным параллельным потоком -\/ например -\/ через графический пользовательский интерфейс. И управление запуском отдельных процедур, так же как у инстанса класса \hyperlink{class_c_v_i_engine_thread}{C\+V\+I\+Engine\+Thread}, осуществляется через модель событийных триггеров. То есть кто-\/то или что-\/то или он сам поднимают флаг события. В цикле проверяется не поднят ли какой-\/нибудь флаг. Если какой-\/то флаг поднят то выполняется запрограммированное действие. Помимо нитей для ускорения обработки расчётов по изображению, запускаются ещё 2 параллельные нити -\/ одна с высоким приоритетом, а другая с обычным. Первая нить отвечает за захват и визуализацию кадров изображения в реальном режиме времени. Вторая нить отвечат за захват и расчёт медлено меняющихся параметров -\/ то есть собственно расчётных параметров методики. }{\pageref{class_c_v_i_engine_base}}{}
\item\contentsline{section}{\hyperlink{class_c_v_i_engine_config}{C\+V\+I\+Engine\+Config} \\*Класс предназначен для управления списком настроечных параметров алгоритмов программы. В программе создаётся только один инстанс данного класса (реализован как член m\+\_\+cfg класса \hyperlink{class_c_v_i_engine_base}{C\+V\+I\+Engine\+Base}). }{\pageref{class_c_v_i_engine_config}}{}
\item\contentsline{section}{\hyperlink{class_c_v_i_engine_event}{C\+V\+I\+Engine\+Event} \\*Предположительно данный класс является программно управляемым событийным триггером }{\pageref{class_c_v_i_engine_event}}{}
\item\contentsline{section}{\hyperlink{class_c_v_i_engine_simple}{C\+V\+I\+Engine\+Simple} \\*Класс реализации алгоритмов, включая алгоритмы подавления шумов (фильтров) с использованием возможностей технологии S\+S\+E. Реализаци¤ не известна, но не имеет никакого значения -\/ можно выбрить любой фильтр подавлени¤ шумов. }{\pageref{class_c_v_i_engine_simple}}{}
\item\contentsline{section}{\hyperlink{class_c_v_i_engine_thread}{C\+V\+I\+Engine\+Thread} \\*Класс для реализации расчётов в многопоточной среде. Является классом для управления одним потоком расчётов. Ускорение расчётов достигается за счёт создания нескольких инстансов данного класса (потоков вычисления), одновременно производящмх общёт изображения. Разделение заданий происходит с помощью разделения между потоками диапазонов строк обрабатываемого изображения. Диапазон обрабатываемых строк инстансом данного класа задаётся членами класса m\+\_\+y\+S,m\+\_\+y\+E. Аналогичное разделение заданий между процессами реализованно в проекте \href{https://github.com/dprotopopov/MedianFilter}{\tt https\+://github.\+com/dprotopopov/\+Median\+Filter}. Сужествуют и другие способы разделения заданий -\/ но от перемены слагаемых сумма не меняется. }{\pageref{class_c_v_i_engine_thread}}{}
\item\contentsline{section}{\hyperlink{class_c_v_i_timer}{C\+V\+I\+Timer} \\*Класс для работы с системными часами }{\pageref{class_c_v_i_timer}}{}
\item\contentsline{section}{\hyperlink{class_c_v_i_timer_sync}{C\+V\+I\+Timer\+Sync} \\*Класс для работы с системными часами }{\pageref{class_c_v_i_timer_sync}}{}
\item\contentsline{section}{\hyperlink{class_f_r_a_m_e___i_m_g}{F\+R\+A\+M\+E\+\_\+\+I\+M\+G} \\*Структура для работы с фрагментами монохромных изображений. Монохромные изображения хранятся в виде последовательности чисел с плавающей точкой. Каждое число соответствует уровню яркости одного пикселя монохромного изображения. Предположительно несколько кадров изображений хранятся в виде одного последовательного массива }{\pageref{class_f_r_a_m_e___i_m_g}}{}
\item\contentsline{section}{\hyperlink{classil_f_r_a_m_e___i_m_g}{il\+F\+R\+A\+M\+E\+\_\+\+I\+M\+G} \\*Элемент массива для работы с фрагментами монохромных изображений }{\pageref{classil_f_r_a_m_e___i_m_g}}{}
\item\contentsline{section}{\hyperlink{classl_f_r_a_m_e___i_m_g}{l\+F\+R\+A\+M\+E\+\_\+\+I\+M\+G} \\*Массив для работы с фрагментами монохромных изображений }{\pageref{classl_f_r_a_m_e___i_m_g}}{}
\item\contentsline{section}{\hyperlink{classmmx__array}{mmx\+\_\+array$<$ T $>$} \\*Структура для хранения одномерных массивов заданного типа данных Вероятно оптимизирован для работы с видеопамятью по технологии M\+M\+X или S\+S\+E }{\pageref{classmmx__array}}{}
\item\contentsline{section}{\hyperlink{classmmx__array2}{mmx\+\_\+array2$<$ T $>$} \\*Структура для хранения двухмерных массивов заданного типа данных Вероятно оптимизирован для работы с видеопамятью по технологии M\+M\+X или S\+S\+E }{\pageref{classmmx__array2}}{}
\item\contentsline{section}{\hyperlink{class_s_u_m___i_m_g}{S\+U\+M\+\_\+\+I\+M\+G} \\*Структура для работы с монохромными изображениями. Монохромные изображения хранятся в виде последовательности чисел с плавающей точкой. Каждое число соответствует уровню яркости одного пикселя монохромного изображения. Предположительно несколько кадров изображений хранятся в виде одного последовательного массива }{\pageref{class_s_u_m___i_m_g}}{}
\item\contentsline{section}{\hyperlink{class_s_u_m_m___s_t_a_t}{S\+U\+M\+M\+\_\+\+S\+T\+A\+T} \\*Структура для хранения статистики по вычисленному дельта-\/изображению }{\pageref{class_s_u_m_m___s_t_a_t}}{}
\item\contentsline{section}{\hyperlink{struct_c_v_i_engine_thread_1_1tag_s_u_m_m___p_t_r}{C\+V\+I\+Engine\+Thread\+::tag\+S\+U\+M\+M\+\_\+\+P\+T\+R} }{\pageref{struct_c_v_i_engine_thread_1_1tag_s_u_m_m___p_t_r}}{}
\item\contentsline{section}{\hyperlink{struct_c_v_i_engine_thread_1_1tag_t_m_p___a_u_r_a___s_t_a_t}{C\+V\+I\+Engine\+Thread\+::tag\+T\+M\+P\+\_\+\+A\+U\+R\+A\+\_\+\+S\+T\+A\+T} }{\pageref{struct_c_v_i_engine_thread_1_1tag_t_m_p___a_u_r_a___s_t_a_t}}{}
\item\contentsline{section}{\hyperlink{struct_c_v_i_engine_thread_1_1tag_t_m_p___s_t_a_t}{C\+V\+I\+Engine\+Thread\+::tag\+T\+M\+P\+\_\+\+S\+T\+A\+T} \\*Структура для хранения статистики по вычисленному фрагменту дельта-\/изображения для одного процесса }{\pageref{struct_c_v_i_engine_thread_1_1tag_t_m_p___s_t_a_t}}{}
\end{DoxyCompactList}
