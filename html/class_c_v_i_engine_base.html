<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>VibraImage: CVIEngineBase Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">VibraImage
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="class_c_v_i_engine_base-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">CVIEngineBase Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Базовый класс для описания алгоритмов программы. Поддерживает выполнение расчётов в многопоточной среде. В программе создаётся только один инстанс данного класса. Для ускорения расчётов он создаёт несколько дочерних инстансов класса <a class="el" href="class_c_v_i_engine_thread.html" title="Класс для реализации расчётов в многопоточной среде. Является классом для управления одним потоком ра...">CVIEngineThread</a>, выполняющих обсчёт отдельных фрагментов полного изображения в параллельных нитях на компьютере. Количество создаваемых инстансов класса <a class="el" href="class_c_v_i_engine_thread.html" title="Класс для реализации расчётов в многопоточной среде. Является классом для управления одним потоком ра...">CVIEngineThread</a> равно количеству процессоров на компьютере, но не более 8-ми. В свою очередь выполнение методов данного класса осуществляется так же в одной из созданных нитей параллельных вычислений, то есть инстанс класса создаётся и управляется внешними механизмами программы как обычным параллельным потоком - например - через графический пользовательский интерфейс. И управление запуском отдельных процедур, так же как у инстанса класса <a class="el" href="class_c_v_i_engine_thread.html" title="Класс для реализации расчётов в многопоточной среде. Является классом для управления одним потоком ра...">CVIEngineThread</a>, осуществляется через модель событийных триггеров. То есть кто-то или что-то или он сам поднимают флаг события. В цикле проверяется не поднят ли какой-нибудь флаг. Если какой-то флаг поднят то выполняется запрограммированное действие. Помимо нитей для ускорения обработки расчётов по изображению, запускаются ещё 2 параллельные нити - одна с высоким приоритетом, а другая с обычным. Первая нить отвечает за захват и визуализацию кадров изображения в реальном режиме времени. Вторая нить отвечат за захват и расчёт медлено меняющихся параметров - то есть собственно расчётных параметров методики.  
 <a href="class_c_v_i_engine_base.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="vi_engine_base_8h_source.html">viEngineBase.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1349de29adc90869f463b17fb03904c1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a1349de29adc90869f463b17fb03904c1">CVIEngineBase</a> (int nThread)</td></tr>
<tr class="memdesc:a1349de29adc90869f463b17fb03904c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Конструктор класса Инициализация переменных программы. Определение оптимального количества параллельных нитей для вычислений.  <a href="#a1349de29adc90869f463b17fb03904c1">More...</a><br /></td></tr>
<tr class="separator:a1349de29adc90869f463b17fb03904c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28dba2a06eda33294836c5241f497112"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a28dba2a06eda33294836c5241f497112">~CVIEngineBase</a> (void)</td></tr>
<tr class="separator:a28dba2a06eda33294836c5241f497112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd0542a6476a6eed4568c900ab5af5d9"><td class="memItemLeft" align="right" valign="top">RGBQUAD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#acd0542a6476a6eed4568c900ab5af5d9">__declspec</a> (align(16)) m_palI[256]</td></tr>
<tr class="separator:acd0542a6476a6eed4568c900ab5af5d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ca94a8d39e8a76e5be4698cc2eff06b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a6ca94a8d39e8a76e5be4698cc2eff06b">AddImageThreadLocal</a> ()</td></tr>
<tr class="memdesc:a6ca94a8d39e8a76e5be4698cc2eff06b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Запуск метода AddImageThreadProc в цикле пока не скажут - Хватит! - while(!m_bDone &amp;&amp; !m_bStop) Если задан настроечный параметр VI_FILTER_FPSDIV, то пасле каждого запуска нить засыпает на указанное количество милисекунд но не более чем на 2 секунды. Иначе вычисления приостанавливаются на 1/4 секунды. Метод вызывается из "рабочей" нити Windows - то есть параллельного процесса для создания которого требуется только указатель на функцию которую надо выполнить  <a href="#a6ca94a8d39e8a76e5be4698cc2eff06b">More...</a><br /></td></tr>
<tr class="separator:a6ca94a8d39e8a76e5be4698cc2eff06b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9fbe14762f4d2bf7d0bffe451a329ee"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#ac9fbe14762f4d2bf7d0bffe451a329ee">AddImageThreadProc</a> ()</td></tr>
<tr class="separator:ac9fbe14762f4d2bf7d0bffe451a329ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a180f4a67ef6b4137c8b8565310aa7834"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a180f4a67ef6b4137c8b8565310aa7834">AddImageThreadLocal8</a> ()</td></tr>
<tr class="memdesc:a180f4a67ef6b4137c8b8565310aa7834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Обработка взведённых флагов сигналов в цикле пока не скажут - Хватит! - while(!m_bDone &amp;&amp; !m_bStop) То есть используется сигнально-событийная схема работы программы. Для каждого сигнала предусмотрен свой обработчик. По окончании обработки каждого сигнала взводится флаг m_evReady. По проверяются и обрабатываются только флаги EVI_ADD8 и EVI_DONE. В цикле производится ожидание до появление флага EVI_DONE. Eсли не был поднят флаг EVI_ADD8, то вызывается метод <a class="el" href="class_c_v_i_engine_base.html#a3fe6ae4f9ac6b9422c22d99878f424f5">AddImage8()</a>; Всегда поднимается флаг готовности кадра m_events[EVI_ADD8_READY].Set(); Метод вызывается из "рабочей" нити Windows - то есть параллельного процесса для создания которого требуется только указатель на функцию которую надо выполнить  <a href="#a180f4a67ef6b4137c8b8565310aa7834">More...</a><br /></td></tr>
<tr class="separator:a180f4a67ef6b4137c8b8565310aa7834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a053908c9c2c18583a13e6f6f79c8eeab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a053908c9c2c18583a13e6f6f79c8eeab">CreateThreads</a> (bool bLock=true)</td></tr>
<tr class="memdesc:a053908c9c2c18583a13e6f6f79c8eeab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Запуск параллельных нитей Windows для параллельных вычислений. Размер исходного изображения берётся из настроечного параметра VI_VAR_SIZE.  <a href="#a053908c9c2c18583a13e6f6f79c8eeab">More...</a><br /></td></tr>
<tr class="separator:a053908c9c2c18583a13e6f6f79c8eeab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0905eba46bb64f25a2d91f8b39a3f994"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a0905eba46bb64f25a2d91f8b39a3f994">CloseThreads</a> (bool bLock=true)</td></tr>
<tr class="memdesc:a0905eba46bb64f25a2d91f8b39a3f994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Останов ранее запущенных параллельных потоков для вычислений.  <a href="#a0905eba46bb64f25a2d91f8b39a3f994">More...</a><br /></td></tr>
<tr class="separator:a0905eba46bb64f25a2d91f8b39a3f994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac886baeaf14b16970d089edaf6767a79"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#ac886baeaf14b16970d089edaf6767a79">AddImage</a> (void *p, int w, int h, int bpp, double t, int nRef=0)</td></tr>
<tr class="memdesc:ac886baeaf14b16970d089edaf6767a79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Процедура получения очередной порции данных для обработки. Список шагов: Действия по оптимизации частоты обработки кадров. Синхронизация таймера. Подготовки различных внутренних структур к готовности получать данные от устройства захвата звука или изображения. Подготовка масок для обрабатываемых изображений. Вызов интерфейсных функций подключаемых программных модулей для получения кадра изображения в m_imgSrc8 или m_imgSrc24 в зависимости от настроек. Поднятие флагов готовности данных для дальнейшей обработки.  <a href="#ac886baeaf14b16970d089edaf6767a79">More...</a><br /></td></tr>
<tr class="separator:ac886baeaf14b16970d089edaf6767a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe6ae4f9ac6b9422c22d99878f424f5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a3fe6ae4f9ac6b9422c22d99878f424f5">AddImage8</a> ()</td></tr>
<tr class="separator:a3fe6ae4f9ac6b9422c22d99878f424f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3426944a03bac2f5a8c135c217f9cf8c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a3426944a03bac2f5a8c135c217f9cf8c">MakeImage</a> (float *pFI, BYTE *pBI, int w, int h)</td></tr>
<tr class="memdesc:a3426944a03bac2f5a8c135c217f9cf8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Процедура обработки очередной порции кадров изображения. Собственно и содержит перечисление всех тех шагов, которые проходит обработка изображения - то есть последовательный вызов процедур обработки и расчётов. Часть расчётов осуществляется в параллельных потоках. Чтобы потоки обработки приступили к соответствующей обработке своего фрагмента изображения, то просто взводится соответствующий флага сигнала у всех параллельных потоков обработки методом Make. Шаги: Сброс если надо - Reset(true); Сдвиг очереди кадров - <a class="el" href="class_c_v_i_engine_base.html#aa1aa2604f40dd77bc49ca6ff8fd81535" title="Сдвиг очереди кадров ">NextSrc()</a>; Сброс ранее рассчитанных данных - <a class="el" href="class_c_v_i_engine_base.html#a10d6138a2c8f4c4c946bf930c268be6b" title="Сброс, очистка и обнуление ранее вычисленных статистических значений. То есть подготовка массива m_st...">ClearStat()</a>; Получение очередного изображения CVIEngineFace::AddImage; Последовательное применение различных обработок кадра - фильтрация шумов, расчёт статистики, расчёт изображения ауры - если по ходу не подали сигнал остановки вычислений; Сведение результатов от фрагментов вместе и расчёт статистических значений; Наконец, вызов методов собственно которые должны реализовавать методику определения чего-то психологического: <a class="el" href="class_c_v_i_engine_base.html#adf949a2b1abf18f519937d3f787c5abf">MakeAnger()</a>; <a class="el" href="class_c_v_i_engine_base.html#a746c67a403f60418bf26e1e686db0c0c">MakeStress()</a>; <a class="el" href="class_c_v_i_engine_base.html#aa77b261660041465a8d3e68a7088dd0d">MakeState()</a>; Вызов процедур подготовки результатов для визуализации; Вызов процедуры визуализации результатов - <a class="el" href="class_c_v_i_engine_base.html#a18c5dc58d55a37295b3dd4c451fb86fc" title="Размер исходного изображения берётся из настроечного параметра VI_VAR_SIZE. ">MakeFaceDraw()</a>; Расчёт затраченного времени на обработку и производительности (FPS), формирование номера сдедующего кадра: m_cfg.PutF1(VI_VAR_FPSOUTR, m_fpsOutR.Put()); m_cfg.PutI1(VI_VAR_NFRAME, m_cfg.GetI1(VI_VAR_NFRAME) + 1); Конец процедуры; Размер исходного изображения берётся из настроечного параметра VI_VAR_SIZE.  <a href="#a3426944a03bac2f5a8c135c217f9cf8c">More...</a><br /></td></tr>
<tr class="separator:a3426944a03bac2f5a8c135c217f9cf8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a930661f73cc7c449c166071631be595d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a930661f73cc7c449c166071631be595d">SetSize</a> (int w, int h, int cnt)</td></tr>
<tr class="memdesc:a930661f73cc7c449c166071631be595d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Сохранение новых размеров изображения в настроечных параметрах VI_VAR_SIZE. Изменение размеров массивов используемых для хранения и обработки изображений. Перезапуск потоков обработки изображений.  <a href="#a930661f73cc7c449c166071631be595d">More...</a><br /></td></tr>
<tr class="separator:a930661f73cc7c449c166071631be595d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a042d710f3a5be21538478ad157680828"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a042d710f3a5be21538478ad157680828">SetCount</a> (int cnt, bool bLock=true)</td></tr>
<tr class="memdesc:a042d710f3a5be21538478ad157680828"><td class="mdescLeft">&#160;</td><td class="mdescRight">Сброс настроечного параметра VI_VAR_NFRAME. Изменение размера массивов m_arrSrc и m_arrDelta до размера cnt + 1 и изменение размеров аллокированной под кадры памяти. Размер исходного изображения берётся из настроечного параметра VI_VAR_SIZE.  <a href="#a042d710f3a5be21538478ad157680828">More...</a><br /></td></tr>
<tr class="separator:a042d710f3a5be21538478ad157680828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4764b56d4269ed5cd101dddf545e039d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a4764b56d4269ed5cd101dddf545e039d">CheckFPSDIV</a> ()</td></tr>
<tr class="memdesc:a4764b56d4269ed5cd101dddf545e039d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Восстановление значения настроечного параметра VI_FILTER_FPSDIV значением настроечного параметра VI_FILTER_FPSDIV_RQST. В случае если настроечный параметр VI_FILTER_FPSDIV отличался от настроечного параметра VI_FILTER_FPSDIV_RQST, производится очистка массива m_srcF.  <a href="#a4764b56d4269ed5cd101dddf545e039d">More...</a><br /></td></tr>
<tr class="separator:a4764b56d4269ed5cd101dddf545e039d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1aa2604f40dd77bc49ca6ff8fd81535"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmmx__array2.html">mmx_array2</a>&lt; float &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#aa1aa2604f40dd77bc49ca6ff8fd81535">NextSrc</a> (void)</td></tr>
<tr class="memdesc:aa1aa2604f40dd77bc49ca6ff8fd81535"><td class="mdescLeft">&#160;</td><td class="mdescRight">Сдвиг очереди кадров  <a href="#aa1aa2604f40dd77bc49ca6ff8fd81535">More...</a><br /></td></tr>
<tr class="separator:aa1aa2604f40dd77bc49ca6ff8fd81535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a305c1b2285ddfcdbb021597f0b3dbd39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a305c1b2285ddfcdbb021597f0b3dbd39">WaitThreads</a> (void)</td></tr>
<tr class="memdesc:a305c1b2285ddfcdbb021597f0b3dbd39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ожидание готовности всех параллельных потоков обработки изображения. Используется для синхронизации параллельных вычислений.  <a href="#a305c1b2285ddfcdbb021597f0b3dbd39">More...</a><br /></td></tr>
<tr class="separator:a305c1b2285ddfcdbb021597f0b3dbd39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af12866653055639e69a61224615af7fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#af12866653055639e69a61224615af7fe">Sync</a> (void)</td></tr>
<tr class="memdesc:af12866653055639e69a61224615af7fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Блокирование ресурсов с ожидание их освобождения другими процессами. То есть после выполнения данного метода все дочерние процессы будут находится в одинаковом статусе и можно считать-записать данные во все из-в них. Точная реализация механизмов семафоров в данной программе неизвестна, но не может сильно отличатся от стандартных механизмов Windows.  <a href="#af12866653055639e69a61224615af7fe">More...</a><br /></td></tr>
<tr class="separator:af12866653055639e69a61224615af7fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b6c77fcb50dcb01f299d7e0f4b05ea6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a4b6c77fcb50dcb01f299d7e0f4b05ea6">SetSummCount</a> (int cnt, int *pN)</td></tr>
<tr class="separator:a4b6c77fcb50dcb01f299d7e0f4b05ea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb6193dca9e4f6c71ad6e77df88bc9f7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#adb6193dca9e4f6c71ad6e77df88bc9f7">GetSummCount</a> (int *pN)</td></tr>
<tr class="separator:adb6193dca9e4f6c71ad6e77df88bc9f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a354f23eda839e4aff3b578fc5ad50363"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a354f23eda839e4aff3b578fc5ad50363">GetSummCount</a> (int pos)</td></tr>
<tr class="separator:a354f23eda839e4aff3b578fc5ad50363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38d38d266d48fad44435eec46a1086a6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a38d38d266d48fad44435eec46a1086a6">SetResultPtr</a> (int id, void *ptr, int w, int h)</td></tr>
<tr class="separator:a38d38d266d48fad44435eec46a1086a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99f7df701bfe9d53121e5cd00167e591"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a99f7df701bfe9d53121e5cd00167e591">GetResultPtr</a> (int id, void **ptr, int *pw, int *ph)</td></tr>
<tr class="memdesc:a99f7df701bfe9d53121e5cd00167e591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Размер исходного изображения берётся из настроечного параметра VI_VAR_SIZE.  <a href="#a99f7df701bfe9d53121e5cd00167e591">More...</a><br /></td></tr>
<tr class="separator:a99f7df701bfe9d53121e5cd00167e591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa59b55fc315394f4c19cb7d95c399913"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#aa59b55fc315394f4c19cb7d95c399913">Make</a> (int command)</td></tr>
<tr class="memdesc:aa59b55fc315394f4c19cb7d95c399913"><td class="mdescLeft">&#160;</td><td class="mdescRight">Поднятие флага сигнала command у всех параллельных процессов. m_therads[k]-&gt;m_events[command].Set(); Параллельные процессы у себя в цикле проверяют поднятость флагов у своего инстанса и выполняют соответствующую сигналу процедуру.  <a href="#aa59b55fc315394f4c19cb7d95c399913">More...</a><br /></td></tr>
<tr class="separator:aa59b55fc315394f4c19cb7d95c399913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e0174d46d3d28931a648e0437f0686d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a1e0174d46d3d28931a648e0437f0686d">GetOptimalThreadCount</a> (void)</td></tr>
<tr class="memdesc:a1e0174d46d3d28931a648e0437f0686d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Расчёт оптимального количества параллельных процессов для данного компьютера, на котором выполняется программв. Данная реализация возвращает просто количество процессоров в на компьютере, но не более 8-ми и не менее 1-го ;) То есть простенько - без вяких лишних околонаучных движений. SYSTEM_INFO info; GetSystemInfo(&amp;info); nProc = info.dwNumberOfProcessors;  <a href="#a1e0174d46d3d28931a648e0437f0686d">More...</a><br /></td></tr>
<tr class="separator:a1e0174d46d3d28931a648e0437f0686d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b86bf7f377f62e7a701fb3466708d04"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a2b86bf7f377f62e7a701fb3466708d04">MakeStatSum</a> (void)</td></tr>
<tr class="memdesc:a2b86bf7f377f62e7a701fb3466708d04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Объединение результатов, рассчитанных в отдельный параллельный процессах для отдельных фрагментов изображений в единый результат в одном месте, то есть для инстанса данного класса и расчёт средних значений по всему изображению. Паралельные процессы сохраняют посчитанные результаты в своих инстансах <a class="el" href="class_c_v_i_engine_thread.html" title="Класс для реализации расчётов в многопоточной среде. Является классом для управления одним потоком ра...">CVIEngineThread</a> в массивах структур m_stat. Данная процедура объединяет все эти результаты в массиве m_stat и что-то делит на количество пикселей в изображении (суммарную яркость, количество ненулевых пикселей и т.д.) - то есть рассчитывает усреднёные значения. Перед выполнении данной процедуры надо убедится в завершении расчётов в каждом отдельном параллельном потоке, поскольку в данном методе вызовов синхронизации нет - здесь полагается что все потоки вычислений уже закончили свои вычисления по текущему кадру. Размер исходного изображения берётся из настроечного параметра VI_VAR_SIZE.  <a href="#a2b86bf7f377f62e7a701fb3466708d04">More...</a><br /></td></tr>
<tr class="separator:a2b86bf7f377f62e7a701fb3466708d04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10d6138a2c8f4c4c946bf930c268be6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a10d6138a2c8f4c4c946bf930c268be6b">ClearStat</a> (void)</td></tr>
<tr class="memdesc:a10d6138a2c8f4c4c946bf930c268be6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Сброс, очистка и обнуление ранее вычисленных статистических значений. То есть подготовка массива m_stat структуры <a class="el" href="class_s_u_m_m___s_t_a_t.html" title="Структура для хранения статистики по вычисленному дельта-изображению ">SUMM_STAT</a> к очередному циклу обработки. Процедура вызывает одноимённый метод для каждого элемента массива m_stat.  <a href="#a10d6138a2c8f4c4c946bf930c268be6b">More...</a><br /></td></tr>
<tr class="separator:a10d6138a2c8f4c4c946bf930c268be6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb910c0d7f06cf1f3ea7b2347aed1751"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#adb910c0d7f06cf1f3ea7b2347aed1751">ClearStat</a> (<a class="el" href="class_s_u_m_m___s_t_a_t.html">SUMM_STAT</a> &amp;S)</td></tr>
<tr class="memdesc:adb910c0d7f06cf1f3ea7b2347aed1751"><td class="mdescLeft">&#160;</td><td class="mdescRight">Сброс, очистка и обнуление ранее вычисленных статистических значений. То есть подготовка данных структуры <a class="el" href="class_s_u_m_m___s_t_a_t.html" title="Структура для хранения статистики по вычисленному дельта-изображению ">SUMM_STAT</a> к очередному циклу обработки.  <a href="#adb910c0d7f06cf1f3ea7b2347aed1751">More...</a><br /></td></tr>
<tr class="separator:adb910c0d7f06cf1f3ea7b2347aed1751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96dd47cc32f324e133644e7f823507ad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a96dd47cc32f324e133644e7f823507ad"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>MakeDefPal</b> (RGBQUAD *pal)</td></tr>
<tr class="separator:a96dd47cc32f324e133644e7f823507ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22ba2d068df7651b957bb7cb00a324be"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a22ba2d068df7651b957bb7cb00a324be"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetMode</b> (int tag, int id)</td></tr>
<tr class="separator:a22ba2d068df7651b957bb7cb00a324be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4507f1ddf8b2931693f85e97dafe7cda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a4507f1ddf8b2931693f85e97dafe7cda">SetRegistry</a> (LPCTSTR group)</td></tr>
<tr class="memdesc:a4507f1ddf8b2931693f85e97dafe7cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Задание идентификатора ключа в реестре Windows для хранения настроечных параметров  <a href="#a4507f1ddf8b2931693f85e97dafe7cda">More...</a><br /></td></tr>
<tr class="separator:a4507f1ddf8b2931693f85e97dafe7cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcb53c55dac3fb076b4e8f5b88e48e6a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#abcb53c55dac3fb076b4e8f5b88e48e6a">GetSrcLine</a> (int x, int y, float *px=0, float *py=0)</td></tr>
<tr class="memdesc:abcb53c55dac3fb076b4e8f5b88e48e6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Размер исходного изображения берётся из настроечного параметра VI_VAR_SIZE.  <a href="#abcb53c55dac3fb076b4e8f5b88e48e6a">More...</a><br /></td></tr>
<tr class="separator:abcb53c55dac3fb076b4e8f5b88e48e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf9d381d837873e8c66babffa6f6bfd1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#aaf9d381d837873e8c66babffa6f6bfd1">GetSrcLine8</a> (int x, int y, float *px=0, float *py=0)</td></tr>
<tr class="separator:aaf9d381d837873e8c66babffa6f6bfd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e295decbf2fabf485467c2dee1bb51f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a1e295decbf2fabf485467c2dee1bb51f">GetSumHist</a> (int id, float *px=0, float *py=0)</td></tr>
<tr class="memdesc:a1e295decbf2fabf485467c2dee1bb51f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Размер исходного изображения берётся из настроечного параметра VI_VAR_SIZE.  <a href="#a1e295decbf2fabf485467c2dee1bb51f">More...</a><br /></td></tr>
<tr class="separator:a1e295decbf2fabf485467c2dee1bb51f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6e23a29501fa69951a0cc9405bae96a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#ad6e23a29501fa69951a0cc9405bae96a">OnNewVar</a> (int id, int subID=0)</td></tr>
<tr class="separator:ad6e23a29501fa69951a0cc9405bae96a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fcb2c48c5d0f103dd1e001f8a4ec35f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a1fcb2c48c5d0f103dd1e001f8a4ec35f">StatUpdate</a> (void)</td></tr>
<tr class="memdesc:a1fcb2c48c5d0f103dd1e001f8a4ec35f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Расчёт величин определённых в методике и записи их в настроечные параметры BOOL disabled2X =m_cfg.GetI1(VI_FILTER_DISABLE_2X); VI_VAR_STAT_INTEGR0A = m_stat[0].sumAin; VI_VAR_STAT_INTEGR0A = m_stat[0].sumBin; VI_VAR_STAT_INTEGR1A = m_stat[1].sumAin; VI_VAR_STAT_INTEGR1A = m_stat[1].sumBin; VI_VAR_STAT_INTEGR2A = m_stat[2].sumAin; VI_VAR_STAT_INTEGR2A = m_stat[2].sumBin; VI_VAR_STAT_RES_A1 = m_stat[0].dsumAin; if(disabled2X) VI_VAR_STAT_RES_A1X = m_stat[0].dsumAin; VI_VAR_STAT_RES_A2 = ( (m_stat[1].auraA.sline.sumL / m_stat[1].auraA.sline.cl) + (m_stat[1].auraA.sline.sumR / m_stat[1].auraA.sline.cr) ) / 2; VI_VAR_STAT_RES_A3 = ( (m_stat[0].auraA.sline.sumL / m_stat[0].auraA.sline.cl) + (m_stat[0].auraA.sline.sumR / m_stat[0].auraA.sline.cr) ) / 2; VI_VAR_STAT_RES_A4 = m_statAVG.Get(VI_VAR_STAT_RES_A1); if(disabled2X) VI_VAR_STAT_RES_A4X = m_statAVG.Get(VI_VAR_STAT_RES_A1X) ; VI_VAR_STAT_RES_F1 = m_stat[0].dsumBin; VI_VAR_STAT_RES_F2 = ( (m_stat[1].auraB.sline.sumL / m_stat[1].auraB.sline.cl) + (m_stat[1].auraB.sline.sumR / m_stat[1].auraB.sline.cr) ) / 2; VI_VAR_STAT_RES_F3 = ( (m_stat[0].auraB.sline.sumL / m_stat[0].auraB.sline.cl) + (m_stat[0].auraB.sline.sumR / m_stat[0].auraB.sline.cr) ) / 2; VI_VAR_STAT_RES_F4 = max(m_stat[0]auraA.sline.maxL, m_stat[0]&gt;auraA.sline.maxR); VI_VAR_STAT_RES_F5 = m_statFFT.GetHfLf(VI_VAR_STAT_RES_F1); if(disabled2X) VI_VAR_STAT_RES_F5X = m_statFFT.GetHfLf(VI_VAR_STAT_RES_F1X); VI_VAR_STAT_RES_S1 = (m_stat[2].auraA.sline.sumL - m_stat[2].auraA.sline.sumR) / (m_stat[2].auraA.sline.cl + m_stat[2].auraA.sline.cr); VI_VAR_STAT_RES_S2 = (m_stat[1].auraA.sline.sumL - m_stat[1].auraA.sline.sumR) / (m_stat[1].auraA.sline.cl + m_stat[1].auraA.sline.cr); VI_VAR_STAT_RES_S2 = (m_stat[0].auraA.sline.sumL - m_stat[0].auraA.sline.sumR) / (m_stat[0].auraA.sline.cl + m_stat[0].auraA.sline.cr); VI_VAR_STAT_RES_S4 = (m_stat[2].auraA.sline.cl - m_stat[2].auraA.sline.cr) / (m_stat[2].auraA.sline.cl + m_stat[2].auraA.sline.cr); VI_VAR_STAT_RES_S5 = (m_stat[1].auraA.sline.cl - m_stat[1].auraA.sline.cr) / (m_stat[1].auraA.sline.cl + m_stat[1].auraA.sline.cr); VI_VAR_STAT_RES_S6 = (m_stat[0].auraA.sline.cl - m_stat[0].auraA.sline.cr) / (m_stat[0].auraA.sline.cl + m_stat[0].auraA.sline.cr); VI_VAR_STAT_RES_S7 = m_stat[0].auraA.sline.maxL - m_stat[0].auraA.sline.maxR; VI_VAR_STAT_RES_P1 = m_stat[1].auraB.statCS; VI_VAR_STAT_RES_P2 = m_stat[0].auraB.statCS; VI_VAR_STAT_RES_P3 = m_stat[1].auraB.statSim; VI_VAR_STAT_RES_P4 = m_stat[0].auraB.statSim; hist = m_cfg.GetI1(VI_FILTER_HISTNW)? m_stat[0].auraA.statHistW :m_stat[0].auraA.statHist; VI_VAR_STAT_RES_P8A = MakeCharming(hist.p, hist.s); VI_VAR_STAT_RES_P9A = MakeEntropyH(hist.p,hist.s); VI_VAR_STAT_RES_P10A = MakeEntropyD(hist.p,hist.s); VI_VAR_STAT_RES_P11A = MakeEntropyX(hist.p,hist.s); VI_VAR_STAT_RES_P12A = MakeEntropyS(hist.p,hist.s); hist = m_cfg.GetI1(VI_FILTER_HISTNW)? m_stat[0].auraB.statHistW :m_stat[0].auraB.statHist; VI_VAR_STAT_RES_P8F = MakeCharming(hist.p, hist.s); VI_VAR_STAT_RES_P9F = MakeEntropyH(hist.p,hist.s); VI_VAR_STAT_RES_P10F = MakeEntropyD(hist.p,hist.s); VI_VAR_STAT_RES_P11F = MakeEntropyX(hist.p,hist.s); VI_VAR_STAT_RES_P12F = MakeEntropyS(hist.p,hist.s); VI_VAR_STAT_RES_P16 = MakeComN(hist.p, hist.s); VI_VAR_STAT_RES_P17 = MakeComS(m_stat[0].auraA); VI_VAR_STAT_RES_P18 = (VI_VAR_STAT_RES_P16 + VI_VAR_STAT_RES_P17) / 2;  <a href="#a1fcb2c48c5d0f103dd1e001f8a4ec35f">More...</a><br /></td></tr>
<tr class="separator:a1fcb2c48c5d0f103dd1e001f8a4ec35f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3a9bb0a97a8ed3ac6e16980dc22a424"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#ae3a9bb0a97a8ed3ac6e16980dc22a424">Stop</a> (void)</td></tr>
<tr class="memdesc:ae3a9bb0a97a8ed3ac6e16980dc22a424"><td class="mdescLeft">&#160;</td><td class="mdescRight">Останов вычислений. Сохранение текущих значений настроечных параметров Останов захвата изображения или звука Останов дочерних потоков вычислений  <a href="#ae3a9bb0a97a8ed3ac6e16980dc22a424">More...</a><br /></td></tr>
<tr class="separator:ae3a9bb0a97a8ed3ac6e16980dc22a424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f426874bb7e7dfa183b7145dab79128"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a2f426874bb7e7dfa183b7145dab79128">Pause</a> (bool bSet)</td></tr>
<tr class="memdesc:a2f426874bb7e7dfa183b7145dab79128"><td class="mdescLeft">&#160;</td><td class="mdescRight">Приостанов вычислений. То есть в VI_FILTER_PAUSE записывается нужный признак. Все процессы периодически считывают VI_FILTER_PAUSE и могут приостановить свои вычисления и расчёты или возобновить.  <a href="#a2f426874bb7e7dfa183b7145dab79128">More...</a><br /></td></tr>
<tr class="separator:a2f426874bb7e7dfa183b7145dab79128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27a3545d7253a59150ea9c16e7b4f0ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a27a3545d7253a59150ea9c16e7b4f0ac">Reset</a> (bool bReset=false)</td></tr>
<tr class="memdesc:a27a3545d7253a59150ea9c16e7b4f0ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Сброс, то есть фактически перезапуск работы приложения. Действия: Пауза; Очиска результатов <a class="el" href="class_c_v_i_engine_base.html#a10d6138a2c8f4c4c946bf930c268be6b" title="Сброс, очистка и обнуление ранее вычисленных статистических значений. То есть подготовка массива m_st...">ClearStat()</a>; Очиска элементов массива m_summ; Обнуление буферов для хранения изображений; Обнуление настроечных параметров из диапазона [VI_STAT_START;VI_STAT_END]; Обнуление настроечных параметров из диапазона [VI_STAT_EXT_START;VI_STAT_EXT_END]; Обнуление m_statFFT, m_statAVG, m_procF6; Обнуление VI_VAR_NDROP; Снятие с паузы; Очистка параметра VI_VAR_RESET;  <a href="#a27a3545d7253a59150ea9c16e7b4f0ac">More...</a><br /></td></tr>
<tr class="separator:a27a3545d7253a59150ea9c16e7b4f0ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a2bee3b656476fdc3cb488a7019d7ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a4a2bee3b656476fdc3cb488a7019d7ae">MakeStatFS2</a> (float *src, int sw, int sh)</td></tr>
<tr class="memdesc:a4a2bee3b656476fdc3cb488a7019d7ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Реализация метода не содержит программного кода.  <a href="#a4a2bee3b656476fdc3cb488a7019d7ae">More...</a><br /></td></tr>
<tr class="separator:a4a2bee3b656476fdc3cb488a7019d7ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d2e5915b3c1c9f6172291305a99bfe5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a7d2e5915b3c1c9f6172291305a99bfe5">FlushFPS</a> (void)</td></tr>
<tr class="separator:a7d2e5915b3c1c9f6172291305a99bfe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2c697a4748558b48789feca6a105042"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#ab2c697a4748558b48789feca6a105042">Start</a> (void)</td></tr>
<tr class="separator:ab2c697a4748558b48789feca6a105042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65b898d96c06c5c9bf9f388b4a70f740"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a65b898d96c06c5c9bf9f388b4a70f740">CheckNRqst</a> (int w, int h)</td></tr>
<tr class="memdesc:a65b898d96c06c5c9bf9f388b4a70f740"><td class="mdescLeft">&#160;</td><td class="mdescRight">Размер исходного изображения берётся из настроечного параметра VI_VAR_SIZE.  <a href="#a65b898d96c06c5c9bf9f388b4a70f740">More...</a><br /></td></tr>
<tr class="separator:a65b898d96c06c5c9bf9f388b4a70f740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad231ab7aee4acfc00e9a55e778443ee4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#ad231ab7aee4acfc00e9a55e778443ee4">MakeResultSrc</a> ()</td></tr>
<tr class="memdesc:ad231ab7aee4acfc00e9a55e778443ee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Размер исходного изображения берётся из настроечного параметра VI_VAR_SIZE.  <a href="#ad231ab7aee4acfc00e9a55e778443ee4">More...</a><br /></td></tr>
<tr class="separator:ad231ab7aee4acfc00e9a55e778443ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a238c46a9344e280e609dcd974ce40a02"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a238c46a9344e280e609dcd974ce40a02">GetStatHistN</a> (int res, int *pHist256, float *pFPS)</td></tr>
<tr class="separator:a238c46a9344e280e609dcd974ce40a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8abf18dfc992c03f0dc9811be62ea5d5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a8abf18dfc992c03f0dc9811be62ea5d5">GetStatHistC</a> (int res, int *pHist256, float *pFPS)</td></tr>
<tr class="separator:a8abf18dfc992c03f0dc9811be62ea5d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18bccff2c758d80e3d720953a0d949c1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a18bccff2c758d80e3d720953a0d949c1">GetStatHistF</a> (int res, int *pHist256, float *pFPS)</td></tr>
<tr class="separator:a18bccff2c758d80e3d720953a0d949c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab631a7093c3f9e3e15b5a84e61358374"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#ab631a7093c3f9e3e15b5a84e61358374">GetStatHistFT</a> (int res, int *pHist256, float *pDT)</td></tr>
<tr class="separator:ab631a7093c3f9e3e15b5a84e61358374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf949a2b1abf18f519937d3f787c5abf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#adf949a2b1abf18f519937d3f787c5abf">MakeAnger</a> (void)</td></tr>
<tr class="separator:adf949a2b1abf18f519937d3f787c5abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a746c67a403f60418bf26e1e686db0c0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a746c67a403f60418bf26e1e686db0c0c">MakeStress</a> (void)</td></tr>
<tr class="separator:a746c67a403f60418bf26e1e686db0c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04eac6867b0a19908706aa4181fc017e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a04eac6867b0a19908706aa4181fc017e">MakeAnger</a> (bool bModeB)</td></tr>
<tr class="separator:a04eac6867b0a19908706aa4181fc017e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35022e842e74177678858dddd0d274ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a35022e842e74177678858dddd0d274ee">MakeStress</a> (bool bModeB)</td></tr>
<tr class="memdesc:a35022e842e74177678858dddd0d274ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Размер исходного изображения берётся из настроечного параметра VI_VAR_SIZE.  <a href="#a35022e842e74177678858dddd0d274ee">More...</a><br /></td></tr>
<tr class="separator:a35022e842e74177678858dddd0d274ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5e0da5e3318399f27c259733db69be0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#af5e0da5e3318399f27c259733db69be0">MakeSin</a> (void)</td></tr>
<tr class="memdesc:af5e0da5e3318399f27c259733db69be0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Чтение настроечного параметра VI_VAR_STAT_CFG_SIN Вычисление sin ( t * 2 * M_PI * n ) где t - значение текущего времени по таймеру m_timer M_PI = 3.1415926... n - значение настроечного параметра VI_VAR_STAT_CFG_SIN И сохранение вычисленного значения в настроечном параметре VI_VAR_STAT_RES_SIN То есть настроечный параметр VI_VAR_STAT_CFG_SIN является частотой синусоидального сигнала настроечный параметр VI_VAR_STAT_RES_SIN хранит значение синусоидального сигнала в текущий момент времени по таймеру m_timer  <a href="#af5e0da5e3318399f27c259733db69be0">More...</a><br /></td></tr>
<tr class="separator:af5e0da5e3318399f27c259733db69be0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b60fbe47fd49415ccbc4e55cc6e858d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a6b60fbe47fd49415ccbc4e55cc6e858d">tmp_aura_draw</a> (void)</td></tr>
<tr class="memdesc:a6b60fbe47fd49415ccbc4e55cc6e858d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Вызов одноимённой функции с параметром из списка парамертов по-очереди VI_RESULT_VI2_A, VI_RESULT_VI2_B, VI_RESULT_VI1_A, VI_RESULT_VI1_B, VI_RESULT_VI0_A, VI_RESULT_VI0_B  <a href="#a6b60fbe47fd49415ccbc4e55cc6e858d">More...</a><br /></td></tr>
<tr class="separator:a6b60fbe47fd49415ccbc4e55cc6e858d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9037ada333cb78e24b8178703c1bace4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a9037ada333cb78e24b8178703c1bace4">tmp_aura_draw</a> (int res)</td></tr>
<tr class="separator:a9037ada333cb78e24b8178703c1bace4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb7d69a59c1067240f248d50d7172ba6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#afb7d69a59c1067240f248d50d7172ba6">OnNewVarDidable</a> (int id)</td></tr>
<tr class="memdesc:afb7d69a59c1067240f248d50d7172ba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Прверка что настроечный параметр с указанным id установлен, и, в противном случае, выполнение операции Reset.  <a href="#afb7d69a59c1067240f248d50d7172ba6">More...</a><br /></td></tr>
<tr class="separator:afb7d69a59c1067240f248d50d7172ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9ac11fcc300832a72d0be60be3419e6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#ab9ac11fcc300832a72d0be60be3419e6">IsMotion</a> (bool bSet=false)</td></tr>
<tr class="memdesc:ab9ac11fcc300832a72d0be60be3419e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Чтение настройки для процедуры сенсора определения факта движения на основе ранее расчитанных статистических данных Если bSet == false и VI_FILTER_DISABLE_VI1 ненеулевой, то VI_FILTER_MOTION_SET сбрасывается и возвращается 0 Иначе если VI_FILTER_MOTION не указан, то VI_FILTER_MOTION_SET сбрасывается и возвращается 0 Иначе производится ряд расчётов по настроечным параметрам, результат записывается в VI_FILTER_MOTION_SET и возвращается вычисленная величина  <a href="#ab9ac11fcc300832a72d0be60be3419e6">More...</a><br /></td></tr>
<tr class="separator:ab9ac11fcc300832a72d0be60be3419e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa31de24bd1b50c4206e8c3a6603985b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#aa31de24bd1b50c4206e8c3a6603985b2">MakeMotion</a> (void)</td></tr>
<tr class="memdesc:aa31de24bd1b50c4206e8c3a6603985b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Вызов метода <a class="el" href="class_c_v_i_engine_base.html#a27a3545d7253a59150ea9c16e7b4f0ac" title="Сброс, то есть фактически перезапуск работы приложения. Действия: Пауза; Очиска результатов ClearStat...">Reset()</a> если выполняется условие от процедуры сенсора движения. Получение текущего параметра для процедуры сенсора движения noise = IsMotion(true); Проверка необходимости вызова процедуры Reset - т.е. проверка условия noise == 3 || noise == -2 || m_statRelease[1].cntAin &gt; 0.7f; Вызов <a class="el" href="class_c_v_i_engine_base.html#a27a3545d7253a59150ea9c16e7b4f0ac" title="Сброс, то есть фактически перезапуск работы приложения. Действия: Пауза; Очиска результатов ClearStat...">Reset()</a> если условие выполняется  <a href="#aa31de24bd1b50c4206e8c3a6603985b2">More...</a><br /></td></tr>
<tr class="separator:aa31de24bd1b50c4206e8c3a6603985b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bedb5c81d496c6c5496ba88cea82eb7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a1bedb5c81d496c6c5496ba88cea82eb7">IsSkip</a> (void)</td></tr>
<tr class="separator:a1bedb5c81d496c6c5496ba88cea82eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa77b261660041465a8d3e68a7088dd0d"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#aa77b261660041465a8d3e68a7088dd0d">MakeState</a> (void)</td></tr>
<tr class="separator:aa77b261660041465a8d3e68a7088dd0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab42744ae341c3653c24ae3fd38bc7ceb"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#ab42744ae341c3653c24ae3fd38bc7ceb">MakeStateMacro</a> (void)</td></tr>
<tr class="memdesc:ab42744ae341c3653c24ae3fd38bc7ceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Размер исходного изображения берётся из настроечного параметра VI_VAR_SIZE.  <a href="#ab42744ae341c3653c24ae3fd38bc7ceb">More...</a><br /></td></tr>
<tr class="separator:ab42744ae341c3653c24ae3fd38bc7ceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a835724aef2b6afbc88d5db31e8a13a08"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a835724aef2b6afbc88d5db31e8a13a08">MakeState</a> (float Ag, float St, float Tn)</td></tr>
<tr class="separator:a835724aef2b6afbc88d5db31e8a13a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18c5dc58d55a37295b3dd4c451fb86fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a18c5dc58d55a37295b3dd4c451fb86fc">MakeFaceDraw</a> ()</td></tr>
<tr class="memdesc:a18c5dc58d55a37295b3dd4c451fb86fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Размер исходного изображения берётся из настроечного параметра VI_VAR_SIZE.  <a href="#a18c5dc58d55a37295b3dd4c451fb86fc">More...</a><br /></td></tr>
<tr class="separator:a18c5dc58d55a37295b3dd4c451fb86fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a784d5489bb89efa567e207d3539de0da"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a784d5489bb89efa567e207d3539de0da">MakeCharming</a> (int *pHist256, int len)</td></tr>
<tr class="separator:a784d5489bb89efa567e207d3539de0da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2617136f50ae63442e88809037ab9ff0"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a2617136f50ae63442e88809037ab9ff0">MakeEntropyX</a> (int *pHist256, int len)</td></tr>
<tr class="memdesc:a2617136f50ae63442e88809037ab9ff0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Вычисление значения энтропии по гистограмме сигнала (Вариант X - заимствование идеи из статистического критерия X^2) Термин энтропия означает численное обозначение некоторой неопределённости и используется в различных областях науки для анализа данных Гистограмма - это вторичная спецификация исходных данный, являющаяся просто подсчётом сколько раз встретился в исходных данных каждый образец. В данном случае исходными данными являются значения яркостей пискелей монохромного изображения, выраженых числами от 0 до 255 Для каждого значения i было подсчитано сколько раз оно встретилось и было занесено в таблицу pHist256 по соответствующему адресу i СУММА pHist256(i) = количество пикселей исходного изображения = ширина*высота Затем по этой таблице был вычислено среднее значение M яркости ненулевых элементов (= математическое ожидание без учёта нулевых значений) Для каждого элементв вычисленно отклонение от линейно-равномерного распределения, то есть Если flen - максимальное значение яркости, то для каждого ненулевого значения i вычисляются коэффициенты dd(i) = (i/flen - M)^2 И вычисляется значение return ( СУММА dd(i)*pHist256(i) / СУММА pHist256(i) ) / sqrt( СУММА dd(i)*dd(i)*pHist256(i) / СУММА pHist256(i) )  <a href="#a2617136f50ae63442e88809037ab9ff0">More...</a><br /></td></tr>
<tr class="separator:a2617136f50ae63442e88809037ab9ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4893abd93ae9de7f3913f24c872b23f8"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a4893abd93ae9de7f3913f24c872b23f8">MakeEntropyH</a> (int *pHist256, int len)</td></tr>
<tr class="memdesc:a4893abd93ae9de7f3913f24c872b23f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Вычисление значения энтропии по гистограмме сигнала (Вариант Н - заимствование идеи из статистического критерия наиболее мощный) Термин энтропия означает численное обозначение некоторой неопределённости и используется в различных областях науки для анализа данных Гистограмма - это вторичная спецификация исходных данный, являющаяся просто подсчётом сколько раз встретился в исходных данных каждый образец. В данном случае исходными данными являются значения яркостей пискелей монохромного изображения, выраженых числами от 0 до 255 Для каждого значения i было подсчитано сколько раз оно встретилось и было занесено в таблицу pHist256 по соответствующему адресу i СУММА pHist256(i) = количество пикселей исходного изображения = ширина*высота Формула: n = СУММА pHist256(i), sum = СУММА ( pHist256(i) / n ) * log10( n * d / pHist256(i) ), return sum; где при подсчёте сумм берутся все i кроме pHist256(i) == 0 или i == 0  <a href="#a4893abd93ae9de7f3913f24c872b23f8">More...</a><br /></td></tr>
<tr class="separator:a4893abd93ae9de7f3913f24c872b23f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a6d774f1ebf9e8bf595c3e3e60f06a7"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a4a6d774f1ebf9e8bf595c3e3e60f06a7">MakeEntropyD</a> (int *pHist256, int len)</td></tr>
<tr class="memdesc:a4a6d774f1ebf9e8bf595c3e3e60f06a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Вычисление значения энтропии по гистограмме сигнала (Вариант D - заимствование идеи из ... видимо совсем собственное творчество) Термин энтропия означает численное обозначение некоторой неопределённости и используется в различных областях науки для анализа данных Гистограмма - это вторичная спецификация исходных данный, являющаяся просто подсчётом сколько раз встретился в исходных данных каждый образец. В данном случае исходными данными являются значения яркостей пискелей монохромного изображения, выраженых числами от 0 до 255 Для каждого значения i было подсчитано сколько раз оно встретилось и было занесено в таблицу pHist256 по соответствующему адресу i СУММА pHist256(i) = количество пикселей исходного изображения = ширина*высота Формула: d = 1.0/len, n = СУММА pHist256(i), sm = СУММА pHist256(i) * log10( pHist256(i) ), Delta = (d*n/2)*pow(10,-1.0*sm/n), return Delta; где при подсчёте сумм берутся все i кроме pHist256(i) == 0 или i == 0  <a href="#a4a6d774f1ebf9e8bf595c3e3e60f06a7">More...</a><br /></td></tr>
<tr class="separator:a4a6d774f1ebf9e8bf595c3e3e60f06a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa13baee159190df5a7fb94bb58f55065"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#aa13baee159190df5a7fb94bb58f55065">MakeEntropyS</a> (int *pHist256, int len)</td></tr>
<tr class="memdesc:aa13baee159190df5a7fb94bb58f55065"><td class="mdescLeft">&#160;</td><td class="mdescRight">Вычисление значения энтропии по гистограмме сигнала (Вариант S - заимствование идеи у инженера-телеграфиста Шенона, работавшего в начале прошлого века в компании Bell) Термин энтропия означает численное обозначение некоторой неопределённости и используется в различных областях науки для анализа данных Гистограмма - это вторичная спецификация исходных данный, являющаяся просто подсчётом сколько раз встретился в исходных данных каждый образец. В данном случае исходными данными являются значения яркостей пискелей монохромного изображения, выраженых числами от 0 до 255 Для каждого значения i было подсчитано сколько раз оно встретилось и было занесено в таблицу pHist256 по соответствующему адресу i СУММА pHist256(i) = количество пикселей исходного изображения = ширина*высота Сперва в таблице pHist256 находим элемент i с наиболее часто вcтречающейся яркостью и для него вычисляется Pm - количество таких пикселей и Xm = m/len = то есть значение яркости выраженное от 0.0 до 1.0 (максимальнвя яркость на данном монохромном изображении равна 1.0) И вычисляется значение return log( СУММА abs( (i*fps/len - Xm) * ( pHist256(i) - Pm ) ) / len ) где fps - количество кадров/сек из настроечных параметров алгоритмов (параметр VI_VAR_FPSOUTR) В данной реализации элементы i, для которых pHist256(i) == 0 или i == 0, не участвуют в расчётах суммы  <a href="#aa13baee159190df5a7fb94bb58f55065">More...</a><br /></td></tr>
<tr class="separator:aa13baee159190df5a7fb94bb58f55065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bde6b4202b8dfa683becb522949e09c"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a4bde6b4202b8dfa683becb522949e09c">MakeComN</a> (int *pHist256, int len)</td></tr>
<tr class="memdesc:a4bde6b4202b8dfa683becb522949e09c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Вычисление значения статистики по гистограмме сигнала. Гистограмма - это вторичная спецификация исходных данный, являющаяся просто подсчётом сколько раз встретился в исходных данных каждый образец. В данном случае исходными данными являются значения яркостей пискелей монохромного изображения, выраженых числами от 0 до 255 Для каждого значения i было подсчитано сколько раз оно встретилось и было занесено в таблицу pHist256 по соответствующему адресу i СУММА pHist256(i) = количество пикселей исходного изображения = ширина*высота Формула: nPI = (0.5/M_PI)*(0.5/M_PI); M = ( СУММА i * pHist256(i) ) / ( СУММА pHist256(i) ); dx(i) = pHist256(i) - M; t(i) = i - M; z(i) = nPI*exp(-0.5*t(i)*t(i)); SumZ = СУММА nPI*exp(-0.5*t(i)*t(i)); S = sqrt( ( СУММА dx(i) * dx(i) * pHist256(i) ) / ( СУММА pHist256(i) ) ); K = ( СУММА z(i) ) / ( СУММА pHist256(i) ); return max( 0.0, min( sqrt( СУММА (pHist256[i] * K - z(i))^2 ) / sqrt( СУММА z(i)^2 ) , 1.0 ) );  <a href="#a4bde6b4202b8dfa683becb522949e09c">More...</a><br /></td></tr>
<tr class="separator:a4bde6b4202b8dfa683becb522949e09c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eaa6b468b27249a359a67ce1ce32c4f"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a6eaa6b468b27249a359a67ce1ce32c4f">MakeComS</a> (<a class="el" href="class_a_u_r_a___s_t_a_t.html">AURA_STAT</a> &amp;aura)</td></tr>
<tr class="separator:a6eaa6b468b27249a359a67ce1ce32c4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2575b5618d3f87d4b10bb1f7294a3bad"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a2575b5618d3f87d4b10bb1f7294a3bad">SrcMaskLoad</a> (LPCWSTR file)</td></tr>
<tr class="memdesc:a2575b5618d3f87d4b10bb1f7294a3bad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Загрузка монохромного изображения m_imgSrcMask из файла Задание размера монохромного изображения m_imgSrcMask равным ширине и высоте изображения в файле Заполнение монохромного изображения m_imgSrcMask значениями 0x00 и 0xFF на основании значений пикселей изображения в файле При этом при заполнении m_imgSrcMask значениями используется вертикально перевёрнутое изображения из файла В m_imgSrcMask записывается значение 0x00 если соответствующий пиксель имеет нулевое значение COLORREF (чёрный цвет) и записывается значение 0xFF во всех остальных случаяж The COLORREF value is used to specify an RGB color.  <a href="#a2575b5618d3f87d4b10bb1f7294a3bad">More...</a><br /></td></tr>
<tr class="separator:a2575b5618d3f87d4b10bb1f7294a3bad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d96cf239567fda73e26950353c69159"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a1d96cf239567fda73e26950353c69159">SrcMaskSave</a> (LPCWSTR file)</td></tr>
<tr class="memdesc:a1d96cf239567fda73e26950353c69159"><td class="mdescLeft">&#160;</td><td class="mdescRight">Сохранение монохромного изображения m_imgSrcMask в файле Сперва каждому пикселю в m_imgSrcMask соответствует 32 бита данных в ОЗУ Каждый байт монохромного изображения заменяется на 4 байта данных в ОЗУ Заполнение файла производится только значениями 0x000000 и 0xFFFFFF на основании значений пикселей в m_imgSrcMask В память записывается значение 0x00000000 если соответствующий пиксель в m_imgSrcMask имеет нулевое значение (чёрный цвет) и записывается значение 0x00FFFFFF во всех остальных случаяж Затем сформированный массив байт созраняется как изображение в формате соответствующем расширению имени файла  <a href="#a1d96cf239567fda73e26950353c69159">More...</a><br /></td></tr>
<tr class="separator:a1d96cf239567fda73e26950353c69159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac394163149bb674cf127f16392f41047"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#ac394163149bb674cf127f16392f41047">SrcMaskReset</a> ()</td></tr>
<tr class="memdesc:ac394163149bb674cf127f16392f41047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Очистка двумерного массива m_imgSrcMask Поддерживает блокирование ресурсов для возможности использования функции из нескольких параллельных процессов.  <a href="#ac394163149bb674cf127f16392f41047">More...</a><br /></td></tr>
<tr class="separator:ac394163149bb674cf127f16392f41047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa12afe22df5c306e03eb855d4fed4fce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#aa12afe22df5c306e03eb855d4fed4fce">SrcMaskErase</a> (int x, int y)</td></tr>
<tr class="memdesc:aa12afe22df5c306e03eb855d4fed4fce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Присвоение нулевого значения элементу двумерного массива m_imgSrcMask по указанным координатам. Если массив m_imgSrcMask пустой то он создаётся с размерами взятыми у m_imgSrc8 и заполняется байтами 0xFF. Поддерживает блокирование ресурсов для возможности использования функции из нескольких параллельных процессов.  <a href="#aa12afe22df5c306e03eb855d4fed4fce">More...</a><br /></td></tr>
<tr class="separator:aa12afe22df5c306e03eb855d4fed4fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa7d51c8145d1094997fc485508dd402"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#aaa7d51c8145d1094997fc485508dd402">GetAura</a> (int *pCWL, int *pCWR, int *pCR, int *pCL, int nProc, bool bB)</td></tr>
<tr class="separator:aaa7d51c8145d1094997fc485508dd402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33937f3f067ec0fa9829c7a40b54be50"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a33937f3f067ec0fa9829c7a40b54be50">CanMakeHist</a> (int id)</td></tr>
<tr class="memdesc:a33937f3f067ec0fa9829c7a40b54be50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Проверка возможности потроения гистограммы указаного типа. Всегда возвращает true. В известном коде программы не используется.  <a href="#a33937f3f067ec0fa9829c7a40b54be50">More...</a><br /></td></tr>
<tr class="separator:a33937f3f067ec0fa9829c7a40b54be50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d144bb4fec300b83067404ffdc9ae6f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a1d144bb4fec300b83067404ffdc9ae6f">NeedSrcImageProc</a> ()</td></tr>
<tr class="memdesc:a1d144bb4fec300b83067404ffdc9ae6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Проверка значения настроечного параметра VI_FACE_ENABLE Возвращает true если параметр VI_FACE_ENABLE установлен в ненулевое значение  <a href="#a1d144bb4fec300b83067404ffdc9ae6f">More...</a><br /></td></tr>
<tr class="separator:a1d144bb4fec300b83067404ffdc9ae6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcadee160287c12571501a09c222bea3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#afcadee160287c12571501a09c222bea3">NewSource</a> ()</td></tr>
<tr class="memdesc:afcadee160287c12571501a09c222bea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Подготовки различных внутренних структур к готовности получать данные от устройства захвата звука или изображения.  <a href="#afcadee160287c12571501a09c222bea3">More...</a><br /></td></tr>
<tr class="separator:afcadee160287c12571501a09c222bea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ad9c65ff1caec8b5042fd55628c515373"><td class="memItemLeft" align="right" valign="top">static DWORD WINAPI&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#ad9c65ff1caec8b5042fd55628c515373">AddImageThread</a> (LPVOID lpParameter)</td></tr>
<tr class="memdesc:ad9c65ff1caec8b5042fd55628c515373"><td class="mdescLeft">&#160;</td><td class="mdescRight">Метод для создания из "рабочей" нити Windows - то есть параллельного процесса для создания которого требуется только указатель на функцию которую надо выполнить и указатель на параметры В качестве параметра передаётся указатель на инстанс данного класса. Эта процедура рабочей нити выполняет только одно действие - вызывает метод AddImageThreadLocal инстанса данного класса.  <a href="#ad9c65ff1caec8b5042fd55628c515373">More...</a><br /></td></tr>
<tr class="separator:ad9c65ff1caec8b5042fd55628c515373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb273d8d1df0ad615bec58b0a9c5f1cc"><td class="memItemLeft" align="right" valign="top">static DWORD WINAPI&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#acb273d8d1df0ad615bec58b0a9c5f1cc">AddImageThread8</a> (LPVOID lpParameter)</td></tr>
<tr class="memdesc:acb273d8d1df0ad615bec58b0a9c5f1cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Метод для создания из "рабочей" нити Windows - то есть параллельного процесса для создания которого требуется только указатель на функцию которую надо выполнить и указатель на параметры В качестве параметра передаётся указатель на инстанс данного класса. Эта процедура рабочей нити выполняет только одно действие - вызывает метод AddImageThreadLocal8 инстанса данного класса.  <a href="#acb273d8d1df0ad615bec58b0a9c5f1cc">More...</a><br /></td></tr>
<tr class="separator:acb273d8d1df0ad615bec58b0a9c5f1cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96058275b74d792351596a389ee29bbd"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a96058275b74d792351596a389ee29bbd">res2n</a> (int res)</td></tr>
<tr class="separator:a96058275b74d792351596a389ee29bbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f8fba45abd4bb564101fb090de26a48"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a2f8fba45abd4bb564101fb090de26a48">IsModeA</a> (int res)</td></tr>
<tr class="separator:a2f8fba45abd4bb564101fb090de26a48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7029194ddd71a7322746e962a3ed5b46"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a7029194ddd71a7322746e962a3ed5b46">IsModeB</a> (int res)</td></tr>
<tr class="separator:a7029194ddd71a7322746e962a3ed5b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ab3883b66e78478803c693b4ad2f5b0e7"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#ab3883b66e78478803c693b4ad2f5b0e7">CallbackOnNewVar</a> )(void *pUserData, int id, int subID)</td></tr>
<tr class="memdesc:ab3883b66e78478803c693b4ad2f5b0e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Указатель на функцию. Видимо относится к механизму хранения настроечных параметров. То есть управление хранением настроечных параметров не жёстко зашито в программу а позволяет использовать различные подключаемые модули к которым надо просто дописать одну фунцию и заполнить переменную указателем на неё.  <a href="#ab3883b66e78478803c693b4ad2f5b0e7">More...</a><br /></td></tr>
<tr class="separator:ab3883b66e78478803c693b4ad2f5b0e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0d4e70811444be165a4b9c2a4aa7aae"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#aa0d4e70811444be165a4b9c2a4aa7aae">CallbackOnNewVarData</a></td></tr>
<tr class="memdesc:aa0d4e70811444be165a4b9c2a4aa7aae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Указатель на данные, передаваемые и возвращаемы в-из функцию вызовом её через указатель CallbackOnNewVar  <a href="#aa0d4e70811444be165a4b9c2a4aa7aae">More...</a><br /></td></tr>
<tr class="separator:aa0d4e70811444be165a4b9c2a4aa7aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f0ddf3af6a98c243d97cbcc9be38e18"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a4f0ddf3af6a98c243d97cbcc9be38e18">CallbackOnImg8</a> )(void *pUserData, BYTE *i8, int w, int h, double t)</td></tr>
<tr class="memdesc:a4f0ddf3af6a98c243d97cbcc9be38e18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Указатель на функцию. Видимо относится к механизму захвата изображений с устройств. То есть получение видеоизображений не жёстко зашито в программу а позволяет использовать различные подключаемые модули к которым надо просто дописать одну фунцию и заполнить переменную указателем на неё. В доступном коде вызов функции по указателю выполняется в методе AddImage данного класса.  <a href="#a4f0ddf3af6a98c243d97cbcc9be38e18">More...</a><br /></td></tr>
<tr class="separator:a4f0ddf3af6a98c243d97cbcc9be38e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfaf1ec8dec9a82c896a90c708dfd756"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#abfaf1ec8dec9a82c896a90c708dfd756">CallbackOnImg8Data</a></td></tr>
<tr class="memdesc:abfaf1ec8dec9a82c896a90c708dfd756"><td class="mdescLeft">&#160;</td><td class="mdescRight">Указатель на данные, передаваемые и возвращаемы в-из функцию вызовом её через указатель CallbackOnImg8  <a href="#abfaf1ec8dec9a82c896a90c708dfd756">More...</a><br /></td></tr>
<tr class="separator:abfaf1ec8dec9a82c896a90c708dfd756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a867f7342010985b0b21beb4feaf354b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_c_v_i_engine_config.html">CVIEngineConfig</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a867f7342010985b0b21beb4feaf354b8">m_cfg</a></td></tr>
<tr class="memdesc:a867f7342010985b0b21beb4feaf354b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Интерфейс для управление значениями настроечных параметров алгоритмов программы (чтение-запись)  <a href="#a867f7342010985b0b21beb4feaf354b8">More...</a><br /></td></tr>
<tr class="separator:a867f7342010985b0b21beb4feaf354b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af996670eec8597e3529bfd0a2ec2585e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_c_v_i_engine_audio2.html">CVIEngineAudio2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#af996670eec8597e3529bfd0a2ec2585e">m_audio</a></td></tr>
<tr class="memdesc:af996670eec8597e3529bfd0a2ec2585e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Видимо реализация API для управления камерой и микрофоном. Вполне возможно что автор сперва сделал полиграф для голоса, а для видео потом расписал. А название осталось.  <a href="#af996670eec8597e3529bfd0a2ec2585e">More...</a><br /></td></tr>
<tr class="separator:af996670eec8597e3529bfd0a2ec2585e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36e1cc3cb814a08af53e9b4076b51dae"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a36e1cc3cb814a08af53e9b4076b51dae">m_nThreadsRqst</a></td></tr>
<tr class="separator:a36e1cc3cb814a08af53e9b4076b51dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0041ab05a40ba6a0bca65c78ea9d8189"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a0041ab05a40ba6a0bca65c78ea9d8189">m_nThreads</a></td></tr>
<tr class="separator:a0041ab05a40ba6a0bca65c78ea9d8189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fdf197fd70d474cf4365abba485c461"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_c_v_i_engine_thread.html">CVIEngineThread</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a4fdf197fd70d474cf4365abba485c461">m_therads</a> [8]</td></tr>
<tr class="separator:a4fdf197fd70d474cf4365abba485c461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66562cd6aaf7fd0f9ade29c9096b9851"><td class="memItemLeft" align="right" valign="top">CMTCriticalSection&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a66562cd6aaf7fd0f9ade29c9096b9851">m_locks</a> [LVI_CNT]</td></tr>
<tr class="separator:a66562cd6aaf7fd0f9ade29c9096b9851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88f59347ca703a36ea9965b96b3ab552"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_c_v_i_engine_event.html">CVIEngineEvent</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a88f59347ca703a36ea9965b96b3ab552">m_events</a> [EVI_CNT]</td></tr>
<tr class="separator:a88f59347ca703a36ea9965b96b3ab552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a928c4511d2e46b9cd4b7c9b3b7322855"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_c_v_i_timer.html">CVITimer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a928c4511d2e46b9cd4b7c9b3b7322855">m_timer</a></td></tr>
<tr class="memdesc:a928c4511d2e46b9cd4b7c9b3b7322855"><td class="mdescLeft">&#160;</td><td class="mdescRight">Реализация работы с системными часами. Успользуется для замеров времени работы процедур обработки изображений с целью оптимизации производительности программы на конкретном компьютере.  <a href="#a928c4511d2e46b9cd4b7c9b3b7322855">More...</a><br /></td></tr>
<tr class="separator:a928c4511d2e46b9cd4b7c9b3b7322855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8709ba629c654585cc38d13ccf3a23b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_c_v_i_timer_sync.html">CVITimerSync</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a8709ba629c654585cc38d13ccf3a23b8">m_timerSync</a></td></tr>
<tr class="memdesc:a8709ba629c654585cc38d13ccf3a23b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Реализация работы с системными часами. Успользуется для замеров времени работы процедур обработки изображений с целью оптимизации производительности программы на конкретном компьютере.  <a href="#a8709ba629c654585cc38d13ccf3a23b8">More...</a><br /></td></tr>
<tr class="separator:a8709ba629c654585cc38d13ccf3a23b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e3c27e7d2ed527eca5445a669080838"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a0e3c27e7d2ed527eca5445a669080838">m_tMakeImage</a></td></tr>
<tr class="separator:a0e3c27e7d2ed527eca5445a669080838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d6409bd350e84190cd6904732c4fe83"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a0d6409bd350e84190cd6904732c4fe83">m_tVideo</a></td></tr>
<tr class="memdesc:a0d6409bd350e84190cd6904732c4fe83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Отметка времени и длительность при обработке изображения кадра  <a href="#a0d6409bd350e84190cd6904732c4fe83">More...</a><br /></td></tr>
<tr class="separator:a0d6409bd350e84190cd6904732c4fe83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98df2a6b3724ab56deee0ed61e3773f8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a98df2a6b3724ab56deee0ed61e3773f8"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>m_tVideoT</b></td></tr>
<tr class="separator:a98df2a6b3724ab56deee0ed61e3773f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45286d497ebc137775cda4999ff9fed6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a45286d497ebc137775cda4999ff9fed6">m_tVideoPrev</a></td></tr>
<tr class="memdesc:a45286d497ebc137775cda4999ff9fed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Отметка времени и длительность при обработке изображения предыдущего кадра  <a href="#a45286d497ebc137775cda4999ff9fed6">More...</a><br /></td></tr>
<tr class="separator:a45286d497ebc137775cda4999ff9fed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac29a85370558b6c5dce1ee2ba1517689"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac29a85370558b6c5dce1ee2ba1517689"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>m_tVideoTPrev</b></td></tr>
<tr class="separator:ac29a85370558b6c5dce1ee2ba1517689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bbf6f3d2d6b80fec8d223ffb44a6791"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a0bbf6f3d2d6b80fec8d223ffb44a6791">m_tVideoDT</a></td></tr>
<tr class="separator:a0bbf6f3d2d6b80fec8d223ffb44a6791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67a15f389d32a0201997a71dc4695803"><td class="memItemLeft" align="right" valign="top">std::list&lt; SRC_IMG &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a67a15f389d32a0201997a71dc4695803">m_srcF</a></td></tr>
<tr class="separator:a67a15f389d32a0201997a71dc4695803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a775fea6c14d39ec6989306017f4f1c9e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a775fea6c14d39ec6989306017f4f1c9e">m_bInit</a></td></tr>
<tr class="memdesc:a775fea6c14d39ec6989306017f4f1c9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Флаг режима инициализации программы  <a href="#a775fea6c14d39ec6989306017f4f1c9e">More...</a><br /></td></tr>
<tr class="separator:a775fea6c14d39ec6989306017f4f1c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13cd33209e328eed98e79086439748b2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a13cd33209e328eed98e79086439748b2">m_bStop</a></td></tr>
<tr class="memdesc:a13cd33209e328eed98e79086439748b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Флаг режима остановки вычислений  <a href="#a13cd33209e328eed98e79086439748b2">More...</a><br /></td></tr>
<tr class="separator:a13cd33209e328eed98e79086439748b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa780c31b49f591af32d9a40e21978201"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#aa780c31b49f591af32d9a40e21978201">m_bDone</a></td></tr>
<tr class="memdesc:aa780c31b49f591af32d9a40e21978201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Флаг режима завершения работы программы  <a href="#aa780c31b49f591af32d9a40e21978201">More...</a><br /></td></tr>
<tr class="separator:aa780c31b49f591af32d9a40e21978201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa909c6b38f749c7b4d848f8b2de331bc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#aa909c6b38f749c7b4d848f8b2de331bc">m_bLock</a></td></tr>
<tr class="separator:aa909c6b38f749c7b4d848f8b2de331bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f173a318d25c068952f2c68f4248208"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a4f173a318d25c068952f2c68f4248208">m_nMake</a></td></tr>
<tr class="separator:a4f173a318d25c068952f2c68f4248208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c62f336b24d613e0320d2e6f676b89b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a2c62f336b24d613e0320d2e6f676b89b">m_cMake</a> [EVI_CNT]</td></tr>
<tr class="separator:a2c62f336b24d613e0320d2e6f676b89b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359f07597366b8c81727c32c9ff931be"><td class="memItemLeft" align="right" valign="top">float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a359f07597366b8c81727c32c9ff931be">m_imgSrcF</a></td></tr>
<tr class="separator:a359f07597366b8c81727c32c9ff931be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa935595a167539c89a4d06a57178d776"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmmx__array2.html">mmx_array2</a>&lt; BYTE &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#aa935595a167539c89a4d06a57178d776">m_imgSrc8</a></td></tr>
<tr class="memdesc:aa935595a167539c89a4d06a57178d776"><td class="mdescLeft">&#160;</td><td class="mdescRight">Двумерный массив монохромного изображения [0;255]  <a href="#aa935595a167539c89a4d06a57178d776">More...</a><br /></td></tr>
<tr class="separator:aa935595a167539c89a4d06a57178d776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a252e6e1285e6063718c7d7a874298363"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmmx__array2.html">mmx_array2</a>&lt; RGBTRIPLE &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a252e6e1285e6063718c7d7a874298363">m_imgSrc24</a></td></tr>
<tr class="memdesc:a252e6e1285e6063718c7d7a874298363"><td class="mdescLeft">&#160;</td><td class="mdescRight">Двумерный массив цветного изображения (RGB). The RGBTRIPLE structure describes a color consisting of relative intensities of red, green, and blue. The bmciColors member of the BITMAPCOREINFO structure consists of an array of RGBTRIPLE structures. <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/dd162939(v=vs.85).aspx">http://msdn.microsoft.com/en-us/library/windows/desktop/dd162939(v=vs.85).aspx</a>  <a href="#a252e6e1285e6063718c7d7a874298363">More...</a><br /></td></tr>
<tr class="separator:a252e6e1285e6063718c7d7a874298363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a879bfc4065da678c4ca67ed828b05a05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmmx__array2.html">mmx_array2</a>&lt; BYTE &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a879bfc4065da678c4ca67ed828b05a05">m_imgSrcMask</a></td></tr>
<tr class="memdesc:a879bfc4065da678c4ca67ed828b05a05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Двумерный массив чисел [0;255] монохромного изображения-маски, хранящий накладываемую на обрабатываемые исходные данные маску яркости пикселей  <a href="#a879bfc4065da678c4ca67ed828b05a05">More...</a><br /></td></tr>
<tr class="separator:a879bfc4065da678c4ca67ed828b05a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b14da4c2f0ccba53a81ab89b89b2a03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classl_f_r_a_m_e___i_m_g.html">lFRAME_IMG</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a9b14da4c2f0ccba53a81ab89b89b2a03">m_arrSrc</a></td></tr>
<tr class="memdesc:a9b14da4c2f0ccba53a81ab89b89b2a03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Массив (очередь) указателей на инстансы типа <a class="el" href="class_f_r_a_m_e___i_m_g.html" title="Структура для работы с фрагментами монохромных изображений. Монохромные изображения хранятся в виде п...">FRAME_IMG</a> (способ хранения очереди исходных изображений)  <a href="#a9b14da4c2f0ccba53a81ab89b89b2a03">More...</a><br /></td></tr>
<tr class="separator:a9b14da4c2f0ccba53a81ab89b89b2a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd1077e6704b0f6bbc788c4d3e7f150e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classl_f_r_a_m_e___i_m_g.html">lFRAME_IMG</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#abd1077e6704b0f6bbc788c4d3e7f150e">m_arrDelta</a></td></tr>
<tr class="memdesc:abd1077e6704b0f6bbc788c4d3e7f150e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Массив (очередь) указателей на инстансы типа <a class="el" href="class_f_r_a_m_e___i_m_g.html" title="Структура для работы с фрагментами монохромных изображений. Монохромные изображения хранятся в виде п...">FRAME_IMG</a> (способ хранения очереди расчитанных дельт-изображений)  <a href="#abd1077e6704b0f6bbc788c4d3e7f150e">More...</a><br /></td></tr>
<tr class="separator:abd1077e6704b0f6bbc788c4d3e7f150e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b3b91816e3f19ec5e531c5ad903be98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmmx__array2.html">mmx_array2</a>&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a0b3b91816e3f19ec5e531c5ad903be98">m_srcMask</a></td></tr>
<tr class="memdesc:a0b3b91816e3f19ec5e531c5ad903be98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Друхмерный массив чисел с плавающей точкой монохромного изображения, хранящий накладываемую на обрабатываемые исходные данные маску яркости пикселей  <a href="#a0b3b91816e3f19ec5e531c5ad903be98">More...</a><br /></td></tr>
<tr class="separator:a0b3b91816e3f19ec5e531c5ad903be98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29b792994f8c587ebdd4296031032f68"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_s_u_m___i_m_g.html">SUM_IMG</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a29b792994f8c587ebdd4296031032f68">m_summ</a></td></tr>
<tr class="separator:a29b792994f8c587ebdd4296031032f68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ff2aaa9eeb589ce6ea73ef5dd62fda"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_s_u_m_m___s_t_a_t.html">SUMM_STAT</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a73ff2aaa9eeb589ce6ea73ef5dd62fda">m_stat</a></td></tr>
<tr class="separator:a73ff2aaa9eeb589ce6ea73ef5dd62fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0a3c99fb49cddb42615132833b483d5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_s_u_m_m___s_t_a_t.html">SUMM_STAT</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#ab0a3c99fb49cddb42615132833b483d5">m_statRelease</a></td></tr>
<tr class="separator:ab0a3c99fb49cddb42615132833b483d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91282745c78c776f8922e20c4f3198f5"><td class="memItemLeft" align="right" valign="top">CVIEngineProc2x&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a91282745c78c776f8922e20c4f3198f5">m_stat2</a></td></tr>
<tr class="separator:a91282745c78c776f8922e20c4f3198f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b9c935b9223f0efcc05282e871254d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; CVIEngineAura6 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#aa4b9c935b9223f0efcc05282e871254d">m_aura6A</a></td></tr>
<tr class="separator:aa4b9c935b9223f0efcc05282e871254d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4415e8a105218982c6358907ae6f380e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; CVIEngineAura6 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a4415e8a105218982c6358907ae6f380e">m_aura6B</a></td></tr>
<tr class="separator:a4415e8a105218982c6358907ae6f380e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afab397345881a9b8a44e6f8eae9805f0"><td class="memItemLeft" align="right" valign="top">CVIEngineVPos&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#afab397345881a9b8a44e6f8eae9805f0">m_vPos</a></td></tr>
<tr class="separator:afab397345881a9b8a44e6f8eae9805f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad8ff35fe2bc6a8d6da03b8f93ea3341"><td class="memItemLeft" align="right" valign="top">CStatAVG_Pack&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#aad8ff35fe2bc6a8d6da03b8f93ea3341">m_statAVG</a></td></tr>
<tr class="separator:aad8ff35fe2bc6a8d6da03b8f93ea3341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a475ef6e1419c21ec5d68097a4cd822ee"><td class="memItemLeft" align="right" valign="top">CStatFFTW_Pack&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a475ef6e1419c21ec5d68097a4cd822ee">m_statFFT</a></td></tr>
<tr class="separator:a475ef6e1419c21ec5d68097a4cd822ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb0ef36905047eafd79bea2911824b7f"><td class="memItemLeft" align="right" valign="top">CStatLDF_Pack&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#abb0ef36905047eafd79bea2911824b7f">m_statLDF</a></td></tr>
<tr class="separator:abb0ef36905047eafd79bea2911824b7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8628211a0ca23ea36cf4059f3ab47f74"><td class="memItemLeft" align="right" valign="top">CStatFN_Pack&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a8628211a0ca23ea36cf4059f3ab47f74">m_statFn</a></td></tr>
<tr class="separator:a8628211a0ca23ea36cf4059f3ab47f74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63cd16114d368eec7c2bce4c4ac8e9c8"><td class="memItemLeft" align="right" valign="top">std::list&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a63cd16114d368eec7c2bce4c4ac8e9c8">m_divMaker</a></td></tr>
<tr class="separator:a63cd16114d368eec7c2bce4c4ac8e9c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34c8596778c068f60030853df3589147"><td class="memItemLeft" align="right" valign="top">std::map&lt; int, DWORD * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a34c8596778c068f60030853df3589147">m_resultPtr</a></td></tr>
<tr class="separator:a34c8596778c068f60030853df3589147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec00e6d3113182f3193b3b4345c4e433"><td class="memItemLeft" align="right" valign="top">SIZE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#aec00e6d3113182f3193b3b4345c4e433">m_resultSize</a></td></tr>
<tr class="separator:aec00e6d3113182f3193b3b4345c4e433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a756c886b931c2c905085558d219d4045"><td class="memItemLeft" align="right" valign="top">DWORD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a756c886b931c2c905085558d219d4045">m_resultVer</a></td></tr>
<tr class="separator:a756c886b931c2c905085558d219d4045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f8d2ef96946316d4b11b4eef209cd35"><td class="memItemLeft" align="right" valign="top">CStatFPS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a3f8d2ef96946316d4b11b4eef209cd35">m_fpsIn</a></td></tr>
<tr class="separator:a3f8d2ef96946316d4b11b4eef209cd35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68263a05d2dcb87863aac27632c6fefa"><td class="memItemLeft" align="right" valign="top">CStatFPS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a68263a05d2dcb87863aac27632c6fefa">m_fpsOutF</a></td></tr>
<tr class="separator:a68263a05d2dcb87863aac27632c6fefa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe15eeaa45219bf0b4c4ffbf08887d4a"><td class="memItemLeft" align="right" valign="top">CStatFPS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#afe15eeaa45219bf0b4c4ffbf08887d4a">m_fpsDropF</a></td></tr>
<tr class="separator:afe15eeaa45219bf0b4c4ffbf08887d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ad39d8c6557ef3c0dd6fb9dc376c8b5"><td class="memItemLeft" align="right" valign="top">CStatFPS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a2ad39d8c6557ef3c0dd6fb9dc376c8b5">m_fpsOutR</a></td></tr>
<tr class="separator:a2ad39d8c6557ef3c0dd6fb9dc376c8b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bd5b977e29332c55f1eaf9a1192d03a"><td class="memItemLeft" align="right" valign="top">CStatFPS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a3bd5b977e29332c55f1eaf9a1192d03a">m_fpsDropR</a></td></tr>
<tr class="separator:a3bd5b977e29332c55f1eaf9a1192d03a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a914dcdad5bb4fa5d7c0363122aa5fa0b"><td class="memItemLeft" align="right" valign="top">CVIEngineCrop&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a914dcdad5bb4fa5d7c0363122aa5fa0b">m_crop</a></td></tr>
<tr class="separator:a914dcdad5bb4fa5d7c0363122aa5fa0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f19c0757146848a5e16bbe1a2a8d6f9"><td class="memItemLeft" align="right" valign="top">CVIEngineDistortion&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a5f19c0757146848a5e16bbe1a2a8d6f9">m_Distortion</a></td></tr>
<tr class="separator:a5f19c0757146848a5e16bbe1a2a8d6f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af130df6a0fc2f75aeea417af333755a2"><td class="memItemLeft" align="right" valign="top">CVIEngineProcDT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#af130df6a0fc2f75aeea417af333755a2">m_procF6</a></td></tr>
<tr class="separator:af130df6a0fc2f75aeea417af333755a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67ce30a4c5018bdb7d33725094454166"><td class="memItemLeft" align="right" valign="top">CVIEngineFace *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_v_i_engine_base.html#a67ce30a4c5018bdb7d33725094454166">m_pFace</a></td></tr>
<tr class="separator:a67ce30a4c5018bdb7d33725094454166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d289b3028ab2b3c1a91bf08de42144e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d289b3028ab2b3c1a91bf08de42144e"></a>
HANDLE&#160;</td><td class="memItemRight" valign="bottom"><b>m_hThreadAddImage</b></td></tr>
<tr class="separator:a4d289b3028ab2b3c1a91bf08de42144e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81b0c7b485feb8404fa06b2e91300d14"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a81b0c7b485feb8404fa06b2e91300d14"></a>
HANDLE&#160;</td><td class="memItemRight" valign="bottom"><b>m_hThreadAddImage8</b></td></tr>
<tr class="separator:a81b0c7b485feb8404fa06b2e91300d14"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Базовый класс для описания алгоритмов программы. Поддерживает выполнение расчётов в многопоточной среде. В программе создаётся только один инстанс данного класса. Для ускорения расчётов он создаёт несколько дочерних инстансов класса <a class="el" href="class_c_v_i_engine_thread.html" title="Класс для реализации расчётов в многопоточной среде. Является классом для управления одним потоком ра...">CVIEngineThread</a>, выполняющих обсчёт отдельных фрагментов полного изображения в параллельных нитях на компьютере. Количество создаваемых инстансов класса <a class="el" href="class_c_v_i_engine_thread.html" title="Класс для реализации расчётов в многопоточной среде. Является классом для управления одним потоком ра...">CVIEngineThread</a> равно количеству процессоров на компьютере, но не более 8-ми. В свою очередь выполнение методов данного класса осуществляется так же в одной из созданных нитей параллельных вычислений, то есть инстанс класса создаётся и управляется внешними механизмами программы как обычным параллельным потоком - например - через графический пользовательский интерфейс. И управление запуском отдельных процедур, так же как у инстанса класса <a class="el" href="class_c_v_i_engine_thread.html" title="Класс для реализации расчётов в многопоточной среде. Является классом для управления одним потоком ра...">CVIEngineThread</a>, осуществляется через модель событийных триггеров. То есть кто-то или что-то или он сам поднимают флаг события. В цикле проверяется не поднят ли какой-нибудь флаг. Если какой-то флаг поднят то выполняется запрограммированное действие. Помимо нитей для ускорения обработки расчётов по изображению, запускаются ещё 2 параллельные нити - одна с высоким приоритетом, а другая с обычным. Первая нить отвечает за захват и визуализацию кадров изображения в реальном режиме времени. Вторая нить отвечат за захват и расчёт медлено меняющихся параметров - то есть собственно расчётных параметров методики. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a1349de29adc90869f463b17fb03904c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CVIEngineBase::CVIEngineBase </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nThread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Конструктор класса Инициализация переменных программы. Определение оптимального количества параллельных нитей для вычислений. </p>

</div>
</div>
<a class="anchor" id="a28dba2a06eda33294836c5241f497112"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CVIEngineBase::~CVIEngineBase </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="acd0542a6476a6eed4568c900ab5af5d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RGBQUAD CVIEngineBase::__declspec </td>
          <td>(</td>
          <td class="paramtype">align(16)&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="ac886baeaf14b16970d089edaf6767a79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CVIEngineBase::AddImage </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bpp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nRef</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Процедура получения очередной порции данных для обработки. Список шагов: Действия по оптимизации частоты обработки кадров. Синхронизация таймера. Подготовки различных внутренних структур к готовности получать данные от устройства захвата звука или изображения. Подготовка масок для обрабатываемых изображений. Вызов интерфейсных функций подключаемых программных модулей для получения кадра изображения в m_imgSrc8 или m_imgSrc24 в зависимости от настроек. Поднятие флагов готовности данных для дальнейшей обработки. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td></td></tr>
    <tr><td class="paramname">w</td><td>Ширина изображения</td></tr>
    <tr><td class="paramname">h</td><td>Высота изображения</td></tr>
    <tr><td class="paramname">bpp</td><td></td></tr>
    <tr><td class="paramname">t</td><td>Отметка времени</td></tr>
    <tr><td class="paramname">nRef</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3fe6ae4f9ac6b9422c22d99878f424f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CVIEngineBase::AddImage8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="ad9c65ff1caec8b5042fd55628c515373"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DWORD CVIEngineBase::AddImageThread </td>
          <td>(</td>
          <td class="paramtype">LPVOID&#160;</td>
          <td class="paramname"><em>lpParameter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Метод для создания из "рабочей" нити Windows - то есть параллельного процесса для создания которого требуется только указатель на функцию которую надо выполнить и указатель на параметры В качестве параметра передаётся указатель на инстанс данного класса. Эта процедура рабочей нити выполняет только одно действие - вызывает метод AddImageThreadLocal инстанса данного класса. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lpParameter</td><td>Указатель на параметры передаваемые при создании параллельной нити Windows, в данном случае - указатель на инстанс данного класса</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acb273d8d1df0ad615bec58b0a9c5f1cc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DWORD CVIEngineBase::AddImageThread8 </td>
          <td>(</td>
          <td class="paramtype">LPVOID&#160;</td>
          <td class="paramname"><em>lpParameter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Метод для создания из "рабочей" нити Windows - то есть параллельного процесса для создания которого требуется только указатель на функцию которую надо выполнить и указатель на параметры В качестве параметра передаётся указатель на инстанс данного класса. Эта процедура рабочей нити выполняет только одно действие - вызывает метод AddImageThreadLocal8 инстанса данного класса. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lpParameter</td><td>Указатель на параметры передаваемые при создании параллельной нити Windows, в данном случае - указатель на инстанс данного класса</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6ca94a8d39e8a76e5be4698cc2eff06b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CVIEngineBase::AddImageThreadLocal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Запуск метода AddImageThreadProc в цикле пока не скажут - Хватит! - while(!m_bDone &amp;&amp; !m_bStop) Если задан настроечный параметр VI_FILTER_FPSDIV, то пасле каждого запуска нить засыпает на указанное количество милисекунд но не более чем на 2 секунды. Иначе вычисления приостанавливаются на 1/4 секунды. Метод вызывается из "рабочей" нити Windows - то есть параллельного процесса для создания которого требуется только указатель на функцию которую надо выполнить </p>

</div>
</div>
<a class="anchor" id="a180f4a67ef6b4137c8b8565310aa7834"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CVIEngineBase::AddImageThreadLocal8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Обработка взведённых флагов сигналов в цикле пока не скажут - Хватит! - while(!m_bDone &amp;&amp; !m_bStop) То есть используется сигнально-событийная схема работы программы. Для каждого сигнала предусмотрен свой обработчик. По окончании обработки каждого сигнала взводится флаг m_evReady. По проверяются и обрабатываются только флаги EVI_ADD8 и EVI_DONE. В цикле производится ожидание до появление флага EVI_DONE. Eсли не был поднят флаг EVI_ADD8, то вызывается метод <a class="el" href="class_c_v_i_engine_base.html#a3fe6ae4f9ac6b9422c22d99878f424f5">AddImage8()</a>; Всегда поднимается флаг готовности кадра m_events[EVI_ADD8_READY].Set(); Метод вызывается из "рабочей" нити Windows - то есть параллельного процесса для создания которого требуется только указатель на функцию которую надо выполнить </p>

</div>
</div>
<a class="anchor" id="ac9fbe14762f4d2bf7d0bffe451a329ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CVIEngineBase::AddImageThreadProc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="a33937f3f067ec0fa9829c7a40b54be50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CVIEngineBase::CanMakeHist </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Проверка возможности потроения гистограммы указаного типа. Всегда возвращает true. В известном коде программы не используется. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Идентификатор типа гистограммы</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4764b56d4269ed5cd101dddf545e039d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CVIEngineBase::CheckFPSDIV </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Восстановление значения настроечного параметра VI_FILTER_FPSDIV значением настроечного параметра VI_FILTER_FPSDIV_RQST. В случае если настроечный параметр VI_FILTER_FPSDIV отличался от настроечного параметра VI_FILTER_FPSDIV_RQST, производится очистка массива m_srcF. </p>

</div>
</div>
<a class="anchor" id="a65b898d96c06c5c9bf9f388b4a70f740"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CVIEngineBase::CheckNRqst </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Размер исходного изображения берётся из настроечного параметра VI_VAR_SIZE. </p>

</div>
</div>
<a class="anchor" id="a10d6138a2c8f4c4c946bf930c268be6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CVIEngineBase::ClearStat </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Сброс, очистка и обнуление ранее вычисленных статистических значений. То есть подготовка массива m_stat структуры <a class="el" href="class_s_u_m_m___s_t_a_t.html" title="Структура для хранения статистики по вычисленному дельта-изображению ">SUMM_STAT</a> к очередному циклу обработки. Процедура вызывает одноимённый метод для каждого элемента массива m_stat. </p>

</div>
</div>
<a class="anchor" id="adb910c0d7f06cf1f3ea7b2347aed1751"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CVIEngineBase::ClearStat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_s_u_m_m___s_t_a_t.html">SUMM_STAT</a> &amp;&#160;</td>
          <td class="paramname"><em>S</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Сброс, очистка и обнуление ранее вычисленных статистических значений. То есть подготовка данных структуры <a class="el" href="class_s_u_m_m___s_t_a_t.html" title="Структура для хранения статистики по вычисленному дельта-изображению ">SUMM_STAT</a> к очередному циклу обработки. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">S</td><td>Ссылка на инстанс структуря <a class="el" href="class_s_u_m_m___s_t_a_t.html" title="Структура для хранения статистики по вычисленному дельта-изображению ">SUMM_STAT</a></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0905eba46bb64f25a2d91f8b39a3f994"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CVIEngineBase::CloseThreads </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bLock</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Останов ранее запущенных параллельных потоков для вычислений. </p>

</div>
</div>
<a class="anchor" id="a053908c9c2c18583a13e6f6f79c8eeab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CVIEngineBase::CreateThreads </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bLock</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Запуск параллельных нитей Windows для параллельных вычислений. Размер исходного изображения берётся из настроечного параметра VI_VAR_SIZE. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bLock</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7d2e5915b3c1c9f6172291305a99bfe5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CVIEngineBase::FlushFPS </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="aaa7d51c8145d1094997fc485508dd402"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CVIEngineBase::GetAura </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pCWL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pCWR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pCR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pCL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nProc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="a1e0174d46d3d28931a648e0437f0686d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CVIEngineBase::GetOptimalThreadCount </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Расчёт оптимального количества параллельных процессов для данного компьютера, на котором выполняется программв. Данная реализация возвращает просто количество процессоров в на компьютере, но не более 8-ми и не менее 1-го ;) То есть простенько - без вяких лишних околонаучных движений. SYSTEM_INFO info; GetSystemInfo(&amp;info); nProc = info.dwNumberOfProcessors; </p>

</div>
</div>
<a class="anchor" id="a99f7df701bfe9d53121e5cd00167e591"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CVIEngineBase::GetResultPtr </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Размер исходного изображения берётся из настроечного параметра VI_VAR_SIZE. </p>

</div>
</div>
<a class="anchor" id="abcb53c55dac3fb076b4e8f5b88e48e6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CVIEngineBase::GetSrcLine </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>px</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>py</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Размер исходного изображения берётся из настроечного параметра VI_VAR_SIZE. </p>

</div>
</div>
<a class="anchor" id="aaf9d381d837873e8c66babffa6f6bfd1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CVIEngineBase::GetSrcLine8 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>px</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>py</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="a8abf18dfc992c03f0dc9811be62ea5d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CVIEngineBase::GetStatHistC </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pHist256</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pFPS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="a18bccff2c758d80e3d720953a0d949c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CVIEngineBase::GetStatHistF </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pHist256</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pFPS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="ab631a7093c3f9e3e15b5a84e61358374"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CVIEngineBase::GetStatHistFT </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pHist256</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pDT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="a238c46a9344e280e609dcd974ce40a02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CVIEngineBase::GetStatHistN </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pHist256</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pFPS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="a1e295decbf2fabf485467c2dee1bb51f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CVIEngineBase::GetSumHist </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>px</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>py</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Размер исходного изображения берётся из настроечного параметра VI_VAR_SIZE. </p>

</div>
</div>
<a class="anchor" id="adb6193dca9e4f6c71ad6e77df88bc9f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CVIEngineBase::GetSummCount </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pN</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="a354f23eda839e4aff3b578fc5ad50363"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CVIEngineBase::GetSummCount </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="a2f8fba45abd4bb564101fb090de26a48"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CVIEngineBase::IsModeA </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7029194ddd71a7322746e962a3ed5b46"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CVIEngineBase::IsModeB </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab9ac11fcc300832a72d0be60be3419e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CVIEngineBase::IsMotion </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bSet</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Чтение настройки для процедуры сенсора определения факта движения на основе ранее расчитанных статистических данных Если bSet == false и VI_FILTER_DISABLE_VI1 ненеулевой, то VI_FILTER_MOTION_SET сбрасывается и возвращается 0 Иначе если VI_FILTER_MOTION не указан, то VI_FILTER_MOTION_SET сбрасывается и возвращается 0 Иначе производится ряд расчётов по настроечным параметрам, результат записывается в VI_FILTER_MOTION_SET и возвращается вычисленная величина </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bSet</td><td>Признак необходимости пересчёта значения настроечного параметра</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1bedb5c81d496c6c5496ba88cea82eb7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CVIEngineBase::IsSkip </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="aa59b55fc315394f4c19cb7d95c399913"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CVIEngineBase::Make </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>command</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Поднятие флага сигнала command у всех параллельных процессов. m_therads[k]-&gt;m_events[command].Set(); Параллельные процессы у себя в цикле проверяют поднятость флагов у своего инстанса и выполняют соответствующую сигналу процедуру. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">command</td><td>Идентификатор сигнала-события</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adf949a2b1abf18f519937d3f787c5abf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CVIEngineBase::MakeAnger </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="a04eac6867b0a19908706aa4181fc017e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CVIEngineBase::MakeAnger </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bModeB</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="a784d5489bb89efa567e207d3539de0da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float CVIEngineBase::MakeCharming </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pHist256</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="a4bde6b4202b8dfa683becb522949e09c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float CVIEngineBase::MakeComN </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pHist256</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Вычисление значения статистики по гистограмме сигнала. Гистограмма - это вторичная спецификация исходных данный, являющаяся просто подсчётом сколько раз встретился в исходных данных каждый образец. В данном случае исходными данными являются значения яркостей пискелей монохромного изображения, выраженых числами от 0 до 255 Для каждого значения i было подсчитано сколько раз оно встретилось и было занесено в таблицу pHist256 по соответствующему адресу i СУММА pHist256(i) = количество пикселей исходного изображения = ширина*высота Формула: nPI = (0.5/M_PI)*(0.5/M_PI); M = ( СУММА i * pHist256(i) ) / ( СУММА pHist256(i) ); dx(i) = pHist256(i) - M; t(i) = i - M; z(i) = nPI*exp(-0.5*t(i)*t(i)); SumZ = СУММА nPI*exp(-0.5*t(i)*t(i)); S = sqrt( ( СУММА dx(i) * dx(i) * pHist256(i) ) / ( СУММА pHist256(i) ) ); K = ( СУММА z(i) ) / ( СУММА pHist256(i) ); return max( 0.0, min( sqrt( СУММА (pHist256[i] * K - z(i))^2 ) / sqrt( СУММА z(i)^2 ) , 1.0 ) ); </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHist256</td><td>Гистограмма монохромного изображения, то есть таблица количества пискелей монохромного изображения имеющих заданную яркость. При этом полагается что монохромное изображение было предствлено в виде массива целых чисел в диапазоне от 0 до len-1 </td></tr>
    <tr><td class="paramname">len</td><td>Размер массива. Фактически является верхней границей яркости исходного монохромного изображения+1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6eaa6b468b27249a359a67ce1ce32c4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float CVIEngineBase::MakeComS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_a_u_r_a___s_t_a_t.html">AURA_STAT</a> &amp;&#160;</td>
          <td class="paramname"><em>aura</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aura</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4a6d774f1ebf9e8bf595c3e3e60f06a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float CVIEngineBase::MakeEntropyD </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pHist256</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Вычисление значения энтропии по гистограмме сигнала (Вариант D - заимствование идеи из ... видимо совсем собственное творчество) Термин энтропия означает численное обозначение некоторой неопределённости и используется в различных областях науки для анализа данных Гистограмма - это вторичная спецификация исходных данный, являющаяся просто подсчётом сколько раз встретился в исходных данных каждый образец. В данном случае исходными данными являются значения яркостей пискелей монохромного изображения, выраженых числами от 0 до 255 Для каждого значения i было подсчитано сколько раз оно встретилось и было занесено в таблицу pHist256 по соответствующему адресу i СУММА pHist256(i) = количество пикселей исходного изображения = ширина*высота Формула: d = 1.0/len, n = СУММА pHist256(i), sm = СУММА pHist256(i) * log10( pHist256(i) ), Delta = (d*n/2)*pow(10,-1.0*sm/n), return Delta; где при подсчёте сумм берутся все i кроме pHist256(i) == 0 или i == 0 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHist256</td><td>Гистограмма монохромного изображения, то есть таблица количества пискелей монохромного изображения имеющих заданную яркость. При этом полагается что монохромное изображение было предствлено в виде массива целых чисел в диапазоне от 0 до len-1 </td></tr>
    <tr><td class="paramname">len</td><td>Размер массива. Фактически является верхней границей яркости исходного монохромного изображения+1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4893abd93ae9de7f3913f24c872b23f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float CVIEngineBase::MakeEntropyH </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pHist256</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Вычисление значения энтропии по гистограмме сигнала (Вариант Н - заимствование идеи из статистического критерия наиболее мощный) Термин энтропия означает численное обозначение некоторой неопределённости и используется в различных областях науки для анализа данных Гистограмма - это вторичная спецификация исходных данный, являющаяся просто подсчётом сколько раз встретился в исходных данных каждый образец. В данном случае исходными данными являются значения яркостей пискелей монохромного изображения, выраженых числами от 0 до 255 Для каждого значения i было подсчитано сколько раз оно встретилось и было занесено в таблицу pHist256 по соответствующему адресу i СУММА pHist256(i) = количество пикселей исходного изображения = ширина*высота Формула: n = СУММА pHist256(i), sum = СУММА ( pHist256(i) / n ) * log10( n * d / pHist256(i) ), return sum; где при подсчёте сумм берутся все i кроме pHist256(i) == 0 или i == 0 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHist256</td><td>Гистограмма монохромного изображения, то есть таблица количества пискелей монохромного изображения имеющих заданную яркость. При этом полагается что монохромное изображение было предствлено в виде массива целых чисел в диапазоне от 0 до len-1 </td></tr>
    <tr><td class="paramname">len</td><td>Размер массива. Фактически является верхней границей яркости исходного монохромного изображения+1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa13baee159190df5a7fb94bb58f55065"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float CVIEngineBase::MakeEntropyS </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pHist256</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Вычисление значения энтропии по гистограмме сигнала (Вариант S - заимствование идеи у инженера-телеграфиста Шенона, работавшего в начале прошлого века в компании Bell) Термин энтропия означает численное обозначение некоторой неопределённости и используется в различных областях науки для анализа данных Гистограмма - это вторичная спецификация исходных данный, являющаяся просто подсчётом сколько раз встретился в исходных данных каждый образец. В данном случае исходными данными являются значения яркостей пискелей монохромного изображения, выраженых числами от 0 до 255 Для каждого значения i было подсчитано сколько раз оно встретилось и было занесено в таблицу pHist256 по соответствующему адресу i СУММА pHist256(i) = количество пикселей исходного изображения = ширина*высота Сперва в таблице pHist256 находим элемент i с наиболее часто вcтречающейся яркостью и для него вычисляется Pm - количество таких пикселей и Xm = m/len = то есть значение яркости выраженное от 0.0 до 1.0 (максимальнвя яркость на данном монохромном изображении равна 1.0) И вычисляется значение return log( СУММА abs( (i*fps/len - Xm) * ( pHist256(i) - Pm ) ) / len ) где fps - количество кадров/сек из настроечных параметров алгоритмов (параметр VI_VAR_FPSOUTR) В данной реализации элементы i, для которых pHist256(i) == 0 или i == 0, не участвуют в расчётах суммы </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHist256</td><td>Гистограмма монохромного изображения, то есть таблица количества пискелей монохромного изображения имеющих заданную яркость. При этом полагается что монохромное изображение было предствлено в виде массива целых чисел в диапазоне от 0 до len-1 </td></tr>
    <tr><td class="paramname">len</td><td>Размер массива. Фактически является верхней границей яркости исходного монохромного изображения+1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2617136f50ae63442e88809037ab9ff0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float CVIEngineBase::MakeEntropyX </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pHist256</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Вычисление значения энтропии по гистограмме сигнала (Вариант X - заимствование идеи из статистического критерия X^2) Термин энтропия означает численное обозначение некоторой неопределённости и используется в различных областях науки для анализа данных Гистограмма - это вторичная спецификация исходных данный, являющаяся просто подсчётом сколько раз встретился в исходных данных каждый образец. В данном случае исходными данными являются значения яркостей пискелей монохромного изображения, выраженых числами от 0 до 255 Для каждого значения i было подсчитано сколько раз оно встретилось и было занесено в таблицу pHist256 по соответствующему адресу i СУММА pHist256(i) = количество пикселей исходного изображения = ширина*высота Затем по этой таблице был вычислено среднее значение M яркости ненулевых элементов (= математическое ожидание без учёта нулевых значений) Для каждого элементв вычисленно отклонение от линейно-равномерного распределения, то есть Если flen - максимальное значение яркости, то для каждого ненулевого значения i вычисляются коэффициенты dd(i) = (i/flen - M)^2 И вычисляется значение return ( СУММА dd(i)*pHist256(i) / СУММА pHist256(i) ) / sqrt( СУММА dd(i)*dd(i)*pHist256(i) / СУММА pHist256(i) ) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHist256</td><td>Гистограмма монохромного изображения, то есть таблица количества пискелей монохромного изображения имеющих заданную яркость. При этом полагается что монохромное изображение было предствлено в виде массива целых чисел в диапазоне от 0 до len-1 </td></tr>
    <tr><td class="paramname">len</td><td>Размер массива. Фактически является верхней границей яркости исходного монохромного изображения+1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a18c5dc58d55a37295b3dd4c451fb86fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CVIEngineBase::MakeFaceDraw </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Размер исходного изображения берётся из настроечного параметра VI_VAR_SIZE. </p>

</div>
</div>
<a class="anchor" id="a3426944a03bac2f5a8c135c217f9cf8c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CVIEngineBase::MakeImage </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>pFI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BYTE *&#160;</td>
          <td class="paramname"><em>pBI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Процедура обработки очередной порции кадров изображения. Собственно и содержит перечисление всех тех шагов, которые проходит обработка изображения - то есть последовательный вызов процедур обработки и расчётов. Часть расчётов осуществляется в параллельных потоках. Чтобы потоки обработки приступили к соответствующей обработке своего фрагмента изображения, то просто взводится соответствующий флага сигнала у всех параллельных потоков обработки методом Make. Шаги: Сброс если надо - Reset(true); Сдвиг очереди кадров - <a class="el" href="class_c_v_i_engine_base.html#aa1aa2604f40dd77bc49ca6ff8fd81535" title="Сдвиг очереди кадров ">NextSrc()</a>; Сброс ранее рассчитанных данных - <a class="el" href="class_c_v_i_engine_base.html#a10d6138a2c8f4c4c946bf930c268be6b" title="Сброс, очистка и обнуление ранее вычисленных статистических значений. То есть подготовка массива m_st...">ClearStat()</a>; Получение очередного изображения CVIEngineFace::AddImage; Последовательное применение различных обработок кадра - фильтрация шумов, расчёт статистики, расчёт изображения ауры - если по ходу не подали сигнал остановки вычислений; Сведение результатов от фрагментов вместе и расчёт статистических значений; Наконец, вызов методов собственно которые должны реализовавать методику определения чего-то психологического: <a class="el" href="class_c_v_i_engine_base.html#adf949a2b1abf18f519937d3f787c5abf">MakeAnger()</a>; <a class="el" href="class_c_v_i_engine_base.html#a746c67a403f60418bf26e1e686db0c0c">MakeStress()</a>; <a class="el" href="class_c_v_i_engine_base.html#aa77b261660041465a8d3e68a7088dd0d">MakeState()</a>; Вызов процедур подготовки результатов для визуализации; Вызов процедуры визуализации результатов - <a class="el" href="class_c_v_i_engine_base.html#a18c5dc58d55a37295b3dd4c451fb86fc" title="Размер исходного изображения берётся из настроечного параметра VI_VAR_SIZE. ">MakeFaceDraw()</a>; Расчёт затраченного времени на обработку и производительности (FPS), формирование номера сдедующего кадра: m_cfg.PutF1(VI_VAR_FPSOUTR, m_fpsOutR.Put()); m_cfg.PutI1(VI_VAR_NFRAME, m_cfg.GetI1(VI_VAR_NFRAME) + 1); Конец процедуры; Размер исходного изображения берётся из настроечного параметра VI_VAR_SIZE. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pFI</td><td>Указатель на массив пикселей в формате чисел с плавющей точной. Видимо зарезервировано для дайнейшего использования.</td></tr>
    <tr><td class="paramname">pBI</td><td>Указатель на массив пикселей в формате целых чисел. Использование зависит от флагов при компилировании программы в исполняемый код.</td></tr>
    <tr><td class="paramname">w</td><td>Ширина изображения</td></tr>
    <tr><td class="paramname">h</td><td>Высота изображения</td></tr>
  </table>
  </dd>
</dl>
<p>Вызов метода <a class="el" href="class_c_v_i_engine_base.html#a27a3545d7253a59150ea9c16e7b4f0ac" title="Сброс, то есть фактически перезапуск работы приложения. Действия: Пауза; Очиска результатов ClearStat...">Reset()</a> если выполняется условие от процедуры сенсора движения. </p>

</div>
</div>
<a class="anchor" id="aa31de24bd1b50c4206e8c3a6603985b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CVIEngineBase::MakeMotion </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Вызов метода <a class="el" href="class_c_v_i_engine_base.html#a27a3545d7253a59150ea9c16e7b4f0ac" title="Сброс, то есть фактически перезапуск работы приложения. Действия: Пауза; Очиска результатов ClearStat...">Reset()</a> если выполняется условие от процедуры сенсора движения. Получение текущего параметра для процедуры сенсора движения noise = IsMotion(true); Проверка необходимости вызова процедуры Reset - т.е. проверка условия noise == 3 || noise == -2 || m_statRelease[1].cntAin &gt; 0.7f; Вызов <a class="el" href="class_c_v_i_engine_base.html#a27a3545d7253a59150ea9c16e7b4f0ac" title="Сброс, то есть фактически перезапуск работы приложения. Действия: Пауза; Очиска результатов ClearStat...">Reset()</a> если условие выполняется </p>
<p>Получение текущего параметра для процедуры сенсора движения </p>

</div>
</div>
<a class="anchor" id="ad231ab7aee4acfc00e9a55e778443ee4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CVIEngineBase::MakeResultSrc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Размер исходного изображения берётся из настроечного параметра VI_VAR_SIZE. </p>

</div>
</div>
<a class="anchor" id="af5e0da5e3318399f27c259733db69be0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CVIEngineBase::MakeSin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Чтение настроечного параметра VI_VAR_STAT_CFG_SIN Вычисление sin ( t * 2 * M_PI * n ) где t - значение текущего времени по таймеру m_timer M_PI = 3.1415926... n - значение настроечного параметра VI_VAR_STAT_CFG_SIN И сохранение вычисленного значения в настроечном параметре VI_VAR_STAT_RES_SIN То есть настроечный параметр VI_VAR_STAT_CFG_SIN является частотой синусоидального сигнала настроечный параметр VI_VAR_STAT_RES_SIN хранит значение синусоидального сигнала в текущий момент времени по таймеру m_timer </p>

</div>
</div>
<a class="anchor" id="aa77b261660041465a8d3e68a7088dd0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float CVIEngineBase::MakeState </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="a835724aef2b6afbc88d5db31e8a13a08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float CVIEngineBase::MakeState </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>Ag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>St</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>Tn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="ab42744ae341c3653c24ae3fd38bc7ceb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float CVIEngineBase::MakeStateMacro </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Размер исходного изображения берётся из настроечного параметра VI_VAR_SIZE. </p>

</div>
</div>
<a class="anchor" id="a4a2bee3b656476fdc3cb488a7019d7ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CVIEngineBase::MakeStatFS2 </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Реализация метода не содержит программного кода. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td></td></tr>
    <tr><td class="paramname">sw</td><td></td></tr>
    <tr><td class="paramname">sh</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2b86bf7f377f62e7a701fb3466708d04"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CVIEngineBase::MakeStatSum </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Объединение результатов, рассчитанных в отдельный параллельный процессах для отдельных фрагментов изображений в единый результат в одном месте, то есть для инстанса данного класса и расчёт средних значений по всему изображению. Паралельные процессы сохраняют посчитанные результаты в своих инстансах <a class="el" href="class_c_v_i_engine_thread.html" title="Класс для реализации расчётов в многопоточной среде. Является классом для управления одним потоком ра...">CVIEngineThread</a> в массивах структур m_stat. Данная процедура объединяет все эти результаты в массиве m_stat и что-то делит на количество пикселей в изображении (суммарную яркость, количество ненулевых пикселей и т.д.) - то есть рассчитывает усреднёные значения. Перед выполнении данной процедуры надо убедится в завершении расчётов в каждом отдельном параллельном потоке, поскольку в данном методе вызовов синхронизации нет - здесь полагается что все потоки вычислений уже закончили свои вычисления по текущему кадру. Размер исходного изображения берётся из настроечного параметра VI_VAR_SIZE. </p>

</div>
</div>
<a class="anchor" id="a746c67a403f60418bf26e1e686db0c0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CVIEngineBase::MakeStress </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="a35022e842e74177678858dddd0d274ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CVIEngineBase::MakeStress </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bModeB</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Размер исходного изображения берётся из настроечного параметра VI_VAR_SIZE. </p>

</div>
</div>
<a class="anchor" id="a1d144bb4fec300b83067404ffdc9ae6f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool CVIEngineBase::NeedSrcImageProc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Проверка значения настроечного параметра VI_FACE_ENABLE Возвращает true если параметр VI_FACE_ENABLE установлен в ненулевое значение </p>

</div>
</div>
<a class="anchor" id="afcadee160287c12571501a09c222bea3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CVIEngineBase::NewSource </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Подготовки различных внутренних структур к готовности получать данные от устройства захвата звука или изображения. </p>

</div>
</div>
<a class="anchor" id="aa1aa2604f40dd77bc49ca6ff8fd81535"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmmx__array2.html">mmx_array2</a>&lt; float &gt; &amp; CVIEngineBase::NextSrc </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Сдвиг очереди кадров </p>

</div>
</div>
<a class="anchor" id="ad6e23a29501fa69951a0cc9405bae96a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CVIEngineBase::OnNewVar </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>subID</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td></td></tr>
    <tr><td class="paramname">subID</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afb7d69a59c1067240f248d50d7172ba6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CVIEngineBase::OnNewVarDidable </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Прверка что настроечный параметр с указанным id установлен, и, в противном случае, выполнение операции Reset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Идентификатор настроечного параметра</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2f426874bb7e7dfa183b7145dab79128"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CVIEngineBase::Pause </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bSet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Приостанов вычислений. То есть в VI_FILTER_PAUSE записывается нужный признак. Все процессы периодически считывают VI_FILTER_PAUSE и могут приостановить свои вычисления и расчёты или возобновить. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bSet</td><td>Признак паузы или продолжения</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a96058275b74d792351596a389ee29bbd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int CVIEngineBase::res2n </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a27a3545d7253a59150ea9c16e7b4f0ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CVIEngineBase::Reset </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bReset</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Сброс, то есть фактически перезапуск работы приложения. Действия: Пауза; Очиска результатов <a class="el" href="class_c_v_i_engine_base.html#a10d6138a2c8f4c4c946bf930c268be6b" title="Сброс, очистка и обнуление ранее вычисленных статистических значений. То есть подготовка массива m_st...">ClearStat()</a>; Очиска элементов массива m_summ; Обнуление буферов для хранения изображений; Обнуление настроечных параметров из диапазона [VI_STAT_START;VI_STAT_END]; Обнуление настроечных параметров из диапазона [VI_STAT_EXT_START;VI_STAT_EXT_END]; Обнуление m_statFFT, m_statAVG, m_procF6; Обнуление VI_VAR_NDROP; Снятие с паузы; Очистка параметра VI_VAR_RESET; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bReset</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a042d710f3a5be21538478ad157680828"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CVIEngineBase::SetCount </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bLock</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Сброс настроечного параметра VI_VAR_NFRAME. Изменение размера массивов m_arrSrc и m_arrDelta до размера cnt + 1 и изменение размеров аллокированной под кадры памяти. Размер исходного изображения берётся из настроечного параметра VI_VAR_SIZE. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cnt</td><td>Новое количество обрабатываемых кадров</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4507f1ddf8b2931693f85e97dafe7cda"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CVIEngineBase::SetRegistry </td>
          <td>(</td>
          <td class="paramtype">LPCTSTR&#160;</td>
          <td class="paramname"><em>group</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Задание идентификатора ключа в реестре Windows для хранения настроечных параметров </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>Идентификатор ключа в реестре Windows</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a38d38d266d48fad44435eec46a1086a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CVIEngineBase::SetResultPtr </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="a930661f73cc7c449c166071631be595d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CVIEngineBase::SetSize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Сохранение новых размеров изображения в настроечных параметрах VI_VAR_SIZE. Изменение размеров массивов используемых для хранения и обработки изображений. Перезапуск потоков обработки изображений. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>Ширина изображения</td></tr>
    <tr><td class="paramname">h</td><td>Высота изображения</td></tr>
    <tr><td class="paramname">cnt</td><td>Новое количество обрабатываемых кадров</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4b6c77fcb50dcb01f299d7e0f4b05ea6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CVIEngineBase::SetSummCount </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pN</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="aa12afe22df5c306e03eb855d4fed4fce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CVIEngineBase::SrcMaskErase </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Присвоение нулевого значения элементу двумерного массива m_imgSrcMask по указанным координатам. Если массив m_imgSrcMask пустой то он создаётся с размерами взятыми у m_imgSrc8 и заполняется байтами 0xFF. Поддерживает блокирование ресурсов для возможности использования функции из нескольких параллельных процессов. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>x координата элемента</td></tr>
    <tr><td class="paramname">y</td><td>y координата элемента</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2575b5618d3f87d4b10bb1f7294a3bad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CVIEngineBase::SrcMaskLoad </td>
          <td>(</td>
          <td class="paramtype">LPCWSTR&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Загрузка монохромного изображения m_imgSrcMask из файла Задание размера монохромного изображения m_imgSrcMask равным ширине и высоте изображения в файле Заполнение монохромного изображения m_imgSrcMask значениями 0x00 и 0xFF на основании значений пикселей изображения в файле При этом при заполнении m_imgSrcMask значениями используется вертикально перевёрнутое изображения из файла В m_imgSrcMask записывается значение 0x00 если соответствующий пиксель имеет нулевое значение COLORREF (чёрный цвет) и записывается значение 0xFF во всех остальных случаяж The COLORREF value is used to specify an RGB color. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>Имя файла</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac394163149bb674cf127f16392f41047"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CVIEngineBase::SrcMaskReset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Очистка двумерного массива m_imgSrcMask Поддерживает блокирование ресурсов для возможности использования функции из нескольких параллельных процессов. </p>

</div>
</div>
<a class="anchor" id="a1d96cf239567fda73e26950353c69159"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CVIEngineBase::SrcMaskSave </td>
          <td>(</td>
          <td class="paramtype">LPCWSTR&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Сохранение монохромного изображения m_imgSrcMask в файле Сперва каждому пикселю в m_imgSrcMask соответствует 32 бита данных в ОЗУ Каждый байт монохромного изображения заменяется на 4 байта данных в ОЗУ Заполнение файла производится только значениями 0x000000 и 0xFFFFFF на основании значений пикселей в m_imgSrcMask В память записывается значение 0x00000000 если соответствующий пиксель в m_imgSrcMask имеет нулевое значение (чёрный цвет) и записывается значение 0x00FFFFFF во всех остальных случаяж Затем сформированный массив байт созраняется как изображение в формате соответствующем расширению имени файла </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>Имя файла</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab2c697a4748558b48789feca6a105042"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CVIEngineBase::Start </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="a1fcb2c48c5d0f103dd1e001f8a4ec35f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CVIEngineBase::StatUpdate </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Расчёт величин определённых в методике и записи их в настроечные параметры BOOL disabled2X =m_cfg.GetI1(VI_FILTER_DISABLE_2X); VI_VAR_STAT_INTEGR0A = m_stat[0].sumAin; VI_VAR_STAT_INTEGR0A = m_stat[0].sumBin; VI_VAR_STAT_INTEGR1A = m_stat[1].sumAin; VI_VAR_STAT_INTEGR1A = m_stat[1].sumBin; VI_VAR_STAT_INTEGR2A = m_stat[2].sumAin; VI_VAR_STAT_INTEGR2A = m_stat[2].sumBin; VI_VAR_STAT_RES_A1 = m_stat[0].dsumAin; if(disabled2X) VI_VAR_STAT_RES_A1X = m_stat[0].dsumAin; VI_VAR_STAT_RES_A2 = ( (m_stat[1].auraA.sline.sumL / m_stat[1].auraA.sline.cl) + (m_stat[1].auraA.sline.sumR / m_stat[1].auraA.sline.cr) ) / 2; VI_VAR_STAT_RES_A3 = ( (m_stat[0].auraA.sline.sumL / m_stat[0].auraA.sline.cl) + (m_stat[0].auraA.sline.sumR / m_stat[0].auraA.sline.cr) ) / 2; VI_VAR_STAT_RES_A4 = m_statAVG.Get(VI_VAR_STAT_RES_A1); if(disabled2X) VI_VAR_STAT_RES_A4X = m_statAVG.Get(VI_VAR_STAT_RES_A1X) ; VI_VAR_STAT_RES_F1 = m_stat[0].dsumBin; VI_VAR_STAT_RES_F2 = ( (m_stat[1].auraB.sline.sumL / m_stat[1].auraB.sline.cl) + (m_stat[1].auraB.sline.sumR / m_stat[1].auraB.sline.cr) ) / 2; VI_VAR_STAT_RES_F3 = ( (m_stat[0].auraB.sline.sumL / m_stat[0].auraB.sline.cl) + (m_stat[0].auraB.sline.sumR / m_stat[0].auraB.sline.cr) ) / 2; VI_VAR_STAT_RES_F4 = max(m_stat[0]auraA.sline.maxL, m_stat[0]&gt;auraA.sline.maxR); VI_VAR_STAT_RES_F5 = m_statFFT.GetHfLf(VI_VAR_STAT_RES_F1); if(disabled2X) VI_VAR_STAT_RES_F5X = m_statFFT.GetHfLf(VI_VAR_STAT_RES_F1X); VI_VAR_STAT_RES_S1 = (m_stat[2].auraA.sline.sumL - m_stat[2].auraA.sline.sumR) / (m_stat[2].auraA.sline.cl + m_stat[2].auraA.sline.cr); VI_VAR_STAT_RES_S2 = (m_stat[1].auraA.sline.sumL - m_stat[1].auraA.sline.sumR) / (m_stat[1].auraA.sline.cl + m_stat[1].auraA.sline.cr); VI_VAR_STAT_RES_S2 = (m_stat[0].auraA.sline.sumL - m_stat[0].auraA.sline.sumR) / (m_stat[0].auraA.sline.cl + m_stat[0].auraA.sline.cr); VI_VAR_STAT_RES_S4 = (m_stat[2].auraA.sline.cl - m_stat[2].auraA.sline.cr) / (m_stat[2].auraA.sline.cl + m_stat[2].auraA.sline.cr); VI_VAR_STAT_RES_S5 = (m_stat[1].auraA.sline.cl - m_stat[1].auraA.sline.cr) / (m_stat[1].auraA.sline.cl + m_stat[1].auraA.sline.cr); VI_VAR_STAT_RES_S6 = (m_stat[0].auraA.sline.cl - m_stat[0].auraA.sline.cr) / (m_stat[0].auraA.sline.cl + m_stat[0].auraA.sline.cr); VI_VAR_STAT_RES_S7 = m_stat[0].auraA.sline.maxL - m_stat[0].auraA.sline.maxR; VI_VAR_STAT_RES_P1 = m_stat[1].auraB.statCS; VI_VAR_STAT_RES_P2 = m_stat[0].auraB.statCS; VI_VAR_STAT_RES_P3 = m_stat[1].auraB.statSim; VI_VAR_STAT_RES_P4 = m_stat[0].auraB.statSim; hist = m_cfg.GetI1(VI_FILTER_HISTNW)? m_stat[0].auraA.statHistW :m_stat[0].auraA.statHist; VI_VAR_STAT_RES_P8A = MakeCharming(hist.p, hist.s); VI_VAR_STAT_RES_P9A = MakeEntropyH(hist.p,hist.s); VI_VAR_STAT_RES_P10A = MakeEntropyD(hist.p,hist.s); VI_VAR_STAT_RES_P11A = MakeEntropyX(hist.p,hist.s); VI_VAR_STAT_RES_P12A = MakeEntropyS(hist.p,hist.s); hist = m_cfg.GetI1(VI_FILTER_HISTNW)? m_stat[0].auraB.statHistW :m_stat[0].auraB.statHist; VI_VAR_STAT_RES_P8F = MakeCharming(hist.p, hist.s); VI_VAR_STAT_RES_P9F = MakeEntropyH(hist.p,hist.s); VI_VAR_STAT_RES_P10F = MakeEntropyD(hist.p,hist.s); VI_VAR_STAT_RES_P11F = MakeEntropyX(hist.p,hist.s); VI_VAR_STAT_RES_P12F = MakeEntropyS(hist.p,hist.s); VI_VAR_STAT_RES_P16 = MakeComN(hist.p, hist.s); VI_VAR_STAT_RES_P17 = MakeComS(m_stat[0].auraA); VI_VAR_STAT_RES_P18 = (VI_VAR_STAT_RES_P16 + VI_VAR_STAT_RES_P17) / 2; </p>

</div>
</div>
<a class="anchor" id="ae3a9bb0a97a8ed3ac6e16980dc22a424"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CVIEngineBase::Stop </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Останов вычислений. Сохранение текущих значений настроечных параметров Останов захвата изображения или звука Останов дочерних потоков вычислений </p>

</div>
</div>
<a class="anchor" id="af12866653055639e69a61224615af7fe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CVIEngineBase::Sync </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Блокирование ресурсов с ожидание их освобождения другими процессами. То есть после выполнения данного метода все дочерние процессы будут находится в одинаковом статусе и можно считать-записать данные во все из-в них. Точная реализация механизмов семафоров в данной программе неизвестна, но не может сильно отличатся от стандартных механизмов Windows. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6b60fbe47fd49415ccbc4e55cc6e858d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CVIEngineBase::tmp_aura_draw </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Вызов одноимённой функции с параметром из списка парамертов по-очереди VI_RESULT_VI2_A, VI_RESULT_VI2_B, VI_RESULT_VI1_A, VI_RESULT_VI1_B, VI_RESULT_VI0_A, VI_RESULT_VI0_B </p>

</div>
</div>
<a class="anchor" id="a9037ada333cb78e24b8178703c1bace4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CVIEngineBase::tmp_aura_draw </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="a305c1b2285ddfcdbb021597f0b3dbd39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CVIEngineBase::WaitThreads </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ожидание готовности всех параллельных потоков обработки изображения. Используется для синхронизации параллельных вычислений. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a4f0ddf3af6a98c243d97cbcc9be38e18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* CVIEngineBase::CallbackOnImg8)(void *pUserData, BYTE *i8, int w, int h, double t)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Указатель на функцию. Видимо относится к механизму захвата изображений с устройств. То есть получение видеоизображений не жёстко зашито в программу а позволяет использовать различные подключаемые модули к которым надо просто дописать одну фунцию и заполнить переменную указателем на неё. В доступном коде вызов функции по указателю выполняется в методе AddImage данного класса. </p>

</div>
</div>
<a class="anchor" id="abfaf1ec8dec9a82c896a90c708dfd756"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* CVIEngineBase::CallbackOnImg8Data</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Указатель на данные, передаваемые и возвращаемы в-из функцию вызовом её через указатель CallbackOnImg8 </p>

</div>
</div>
<a class="anchor" id="ab3883b66e78478803c693b4ad2f5b0e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* CVIEngineBase::CallbackOnNewVar)(void *pUserData, int id, int subID)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Указатель на функцию. Видимо относится к механизму хранения настроечных параметров. То есть управление хранением настроечных параметров не жёстко зашито в программу а позволяет использовать различные подключаемые модули к которым надо просто дописать одну фунцию и заполнить переменную указателем на неё. </p>

</div>
</div>
<a class="anchor" id="aa0d4e70811444be165a4b9c2a4aa7aae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* CVIEngineBase::CallbackOnNewVarData</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Указатель на данные, передаваемые и возвращаемы в-из функцию вызовом её через указатель CallbackOnNewVar </p>

</div>
</div>
<a class="anchor" id="abd1077e6704b0f6bbc788c4d3e7f150e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classl_f_r_a_m_e___i_m_g.html">lFRAME_IMG</a> CVIEngineBase::m_arrDelta</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Массив (очередь) указателей на инстансы типа <a class="el" href="class_f_r_a_m_e___i_m_g.html" title="Структура для работы с фрагментами монохромных изображений. Монохромные изображения хранятся в виде п...">FRAME_IMG</a> (способ хранения очереди расчитанных дельт-изображений) </p>

</div>
</div>
<a class="anchor" id="a9b14da4c2f0ccba53a81ab89b89b2a03"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classl_f_r_a_m_e___i_m_g.html">lFRAME_IMG</a> CVIEngineBase::m_arrSrc</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Массив (очередь) указателей на инстансы типа <a class="el" href="class_f_r_a_m_e___i_m_g.html" title="Структура для работы с фрагментами монохромных изображений. Монохромные изображения хранятся в виде п...">FRAME_IMG</a> (способ хранения очереди исходных изображений) </p>

</div>
</div>
<a class="anchor" id="af996670eec8597e3529bfd0a2ec2585e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_v_i_engine_audio2.html">CVIEngineAudio2</a> CVIEngineBase::m_audio</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Видимо реализация API для управления камерой и микрофоном. Вполне возможно что автор сперва сделал полиграф для голоса, а для видео потом расписал. А название осталось. </p>

</div>
</div>
<a class="anchor" id="aa4b9c935b9223f0efcc05282e871254d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;CVIEngineAura6&gt; CVIEngineBase::m_aura6A</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="a4415e8a105218982c6358907ae6f380e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;CVIEngineAura6&gt; CVIEngineBase::m_aura6B</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="aa780c31b49f591af32d9a40e21978201"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CVIEngineBase::m_bDone</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Флаг режима завершения работы программы </p>

</div>
</div>
<a class="anchor" id="a775fea6c14d39ec6989306017f4f1c9e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CVIEngineBase::m_bInit</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Флаг режима инициализации программы </p>

</div>
</div>
<a class="anchor" id="aa909c6b38f749c7b4d848f8b2de331bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CVIEngineBase::m_bLock</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="a13cd33209e328eed98e79086439748b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CVIEngineBase::m_bStop</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Флаг режима остановки вычислений </p>

</div>
</div>
<a class="anchor" id="a867f7342010985b0b21beb4feaf354b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_v_i_engine_config.html">CVIEngineConfig</a> CVIEngineBase::m_cfg</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Интерфейс для управление значениями настроечных параметров алгоритмов программы (чтение-запись) </p>

</div>
</div>
<a class="anchor" id="a2c62f336b24d613e0320d2e6f676b89b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CVIEngineBase::m_cMake[EVI_CNT]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="a914dcdad5bb4fa5d7c0363122aa5fa0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CVIEngineCrop CVIEngineBase::m_crop</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="a5f19c0757146848a5e16bbe1a2a8d6f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CVIEngineDistortion CVIEngineBase::m_Distortion</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="a63cd16114d368eec7c2bce4c4ac8e9c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;int&gt; CVIEngineBase::m_divMaker</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="a88f59347ca703a36ea9965b96b3ab552"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_v_i_engine_event.html">CVIEngineEvent</a> CVIEngineBase::m_events[EVI_CNT]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="afe15eeaa45219bf0b4c4ffbf08887d4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CStatFPS CVIEngineBase::m_fpsDropF</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="a3bd5b977e29332c55f1eaf9a1192d03a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CStatFPS CVIEngineBase::m_fpsDropR</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="a3f8d2ef96946316d4b11b4eef209cd35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CStatFPS CVIEngineBase::m_fpsIn</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="a68263a05d2dcb87863aac27632c6fefa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CStatFPS CVIEngineBase::m_fpsOutF</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="a2ad39d8c6557ef3c0dd6fb9dc376c8b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CStatFPS CVIEngineBase::m_fpsOutR</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="a252e6e1285e6063718c7d7a874298363"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmmx__array2.html">mmx_array2</a>&lt;RGBTRIPLE&gt; CVIEngineBase::m_imgSrc24</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Двумерный массив цветного изображения (RGB). The RGBTRIPLE structure describes a color consisting of relative intensities of red, green, and blue. The bmciColors member of the BITMAPCOREINFO structure consists of an array of RGBTRIPLE structures. <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/dd162939(v=vs.85).aspx">http://msdn.microsoft.com/en-us/library/windows/desktop/dd162939(v=vs.85).aspx</a> </p>

</div>
</div>
<a class="anchor" id="aa935595a167539c89a4d06a57178d776"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmmx__array2.html">mmx_array2</a>&lt;BYTE&gt; CVIEngineBase::m_imgSrc8</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Двумерный массив монохромного изображения [0;255] </p>

</div>
</div>
<a class="anchor" id="a359f07597366b8c81727c32c9ff931be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float* CVIEngineBase::m_imgSrcF</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="a879bfc4065da678c4ca67ed828b05a05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmmx__array2.html">mmx_array2</a>&lt;BYTE&gt; CVIEngineBase::m_imgSrcMask</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Двумерный массив чисел [0;255] монохромного изображения-маски, хранящий накладываемую на обрабатываемые исходные данные маску яркости пикселей </p>

</div>
</div>
<a class="anchor" id="a66562cd6aaf7fd0f9ade29c9096b9851"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CMTCriticalSection CVIEngineBase::m_locks[LVI_CNT]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="a4f173a318d25c068952f2c68f4248208"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CVIEngineBase::m_nMake</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="a0041ab05a40ba6a0bca65c78ea9d8189"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CVIEngineBase::m_nThreads</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="a36e1cc3cb814a08af53e9b4076b51dae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CVIEngineBase::m_nThreadsRqst</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="a67ce30a4c5018bdb7d33725094454166"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CVIEngineFace* CVIEngineBase::m_pFace</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="af130df6a0fc2f75aeea417af333755a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CVIEngineProcDT CVIEngineBase::m_procF6</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="a34c8596778c068f60030853df3589147"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;int, DWORD*&gt; CVIEngineBase::m_resultPtr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="aec00e6d3113182f3193b3b4345c4e433"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SIZE CVIEngineBase::m_resultSize</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="a756c886b931c2c905085558d219d4045"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DWORD CVIEngineBase::m_resultVer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="a67a15f389d32a0201997a71dc4695803"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt; SRC_IMG &gt; CVIEngineBase::m_srcF</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="a0b3b91816e3f19ec5e531c5ad903be98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmmx__array2.html">mmx_array2</a>&lt;float&gt; CVIEngineBase::m_srcMask</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Друхмерный массив чисел с плавающей точкой монохромного изображения, хранящий накладываемую на обрабатываемые исходные данные маску яркости пикселей </p>

</div>
</div>
<a class="anchor" id="a73ff2aaa9eeb589ce6ea73ef5dd62fda"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="class_s_u_m_m___s_t_a_t.html">SUMM_STAT</a>&gt; CVIEngineBase::m_stat</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="a91282745c78c776f8922e20c4f3198f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CVIEngineProc2x CVIEngineBase::m_stat2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="aad8ff35fe2bc6a8d6da03b8f93ea3341"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CStatAVG_Pack CVIEngineBase::m_statAVG</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="a475ef6e1419c21ec5d68097a4cd822ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CStatFFTW_Pack CVIEngineBase::m_statFFT</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="a8628211a0ca23ea36cf4059f3ab47f74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CStatFN_Pack CVIEngineBase::m_statFn</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="abb0ef36905047eafd79bea2911824b7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CStatLDF_Pack CVIEngineBase::m_statLDF</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="ab0a3c99fb49cddb42615132833b483d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="class_s_u_m_m___s_t_a_t.html">SUMM_STAT</a>&gt; CVIEngineBase::m_statRelease</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="a29b792994f8c587ebdd4296031032f68"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="class_s_u_m___i_m_g.html">SUM_IMG</a>&gt; CVIEngineBase::m_summ</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="a4fdf197fd70d474cf4365abba485c461"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_v_i_engine_thread.html">CVIEngineThread</a>* CVIEngineBase::m_therads[8]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="a928c4511d2e46b9cd4b7c9b3b7322855"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_v_i_timer.html">CVITimer</a> CVIEngineBase::m_timer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Реализация работы с системными часами. Успользуется для замеров времени работы процедур обработки изображений с целью оптимизации производительности программы на конкретном компьютере. </p>

</div>
</div>
<a class="anchor" id="a8709ba629c654585cc38d13ccf3a23b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_c_v_i_timer_sync.html">CVITimerSync</a> CVIEngineBase::m_timerSync</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Реализация работы с системными часами. Успользуется для замеров времени работы процедур обработки изображений с целью оптимизации производительности программы на конкретном компьютере. </p>

</div>
</div>
<a class="anchor" id="a0e3c27e7d2ed527eca5445a669080838"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double CVIEngineBase::m_tMakeImage</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="a0d6409bd350e84190cd6904732c4fe83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double CVIEngineBase::m_tVideo</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Отметка времени и длительность при обработке изображения кадра </p>

</div>
</div>
<a class="anchor" id="a0bbf6f3d2d6b80fec8d223ffb44a6791"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double CVIEngineBase::m_tVideoDT</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<a class="anchor" id="a45286d497ebc137775cda4999ff9fed6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double CVIEngineBase::m_tVideoPrev</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Отметка времени и длительность при обработке изображения предыдущего кадра </p>

</div>
</div>
<a class="anchor" id="afab397345881a9b8a44e6f8eae9805f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CVIEngineVPos CVIEngineBase::m_vPos</td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>code/<a class="el" href="vi_engine_base_8h_source.html">viEngineBase.h</a></li>
<li>code/viEngineBase.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Oct 18 2014 23:52:38 for VibraImage by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
